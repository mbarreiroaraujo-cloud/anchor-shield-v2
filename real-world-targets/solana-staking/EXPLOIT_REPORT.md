# Exploit Report: solana-staking (rpajo/solana-staking)

## Program Overview

- **Source**: rpajo/solana-staking
- **Domain**: NFT staking (SkinFlip)
- **Lines**: 204
- **Anchor version**: Pre-0.20 (uses ProgramAccount, older syntax)
- **Status**: Community prototype, unaudited

## Compilation

- **Solana CLI**: Not available in environment
- **Bankrun execution**: Not possible without cargo-build-sbf
- **Alternative**: Python simulation exploits (faithful dataclass models)

## Exploits

### Exploit 1: Incomplete Unstake — NFT Permanently Lost (SEM-001, Critical)

**File**: `exploits/exploit_solana_staking_001_incomplete_unstake.py`

**Vulnerability**: The `unstake` function (lib.rs:85-102) only computes `time_diff` and logs it. It **never**:
1. Transfers the NFT back from vault to holder (missing `token::transfer` CPI)
2. Decrements `staking_machine.staked_nfts`
3. Closes the staking account

**Vulnerable code** (lib.rs:85-102):
```rust
pub fn unstake(ctx: Context<UnstakeInstructionStruct>, bump: u8, nft_token: Pubkey) -> ProgramResult {
    let time_diff = clock.unix_timestamp - nft_stake_data.staking_date;
    msg!("Staked at {}, time diff: {}", nft_stake_data.staking_date, time_diff);
    Ok(())  // <-- No transfer, no state update
}
```

**Exploit scenario**:
1. User stakes NFT (transferred to vault via CPI)
2. User calls unstake — function returns Ok(())
3. NFT remains in vault, permanently lost to user

**Simulation result**: CONFIRMED
- After stake: holder=0 NFT, vault=1 NFT, staked_nfts=1
- After unstake: holder=0 NFT, vault=1 NFT, staked_nfts=1 (unchanged)
- NFT permanently locked in vault

**Fix**: Add `token::transfer` CPI in unstake to return NFT, decrement `staked_nfts`.

### Exploit 2: Missing Signer Allows Unauthorized Unstake (SEM-002, High)

**File**: `exploits/exploit_solana_staking_002_missing_signer.py`

**Vulnerability**: `nft_holder` in `UnstakeInstructionStruct` (lib.rs:172-186) is `AccountInfo<'info>` without the `Signer` constraint. Anyone can call unstake for any holder by providing their public key.

**Vulnerable struct** (lib.rs:170-186):
```rust
#[derive(Accounts)]
pub struct UnstakeInstructionStruct<'info> {
    #[account(mut)]
    pub staking_machine: Account<'info, StakingMachine>,
    #[account()]                               // <-- No Signer!
    pub nft_holder: AccountInfo<'info>,
    #[account(seeds = [...], bump = bump)]
    pub nft_stake_data: ProgramAccount<'info, StakingAccount>,
    pub clock: Sysvar<'info, Clock>,
}
```

**Key insight**: In `stake`, nft_holder also lacks Signer, but the CPI to `token::transfer` implicitly requires the holder to sign (as authority). In `unstake`, there is NO CPI — so no implicit signer enforcement exists.

**Exploit scenario**:
1. Victim stakes NFT
2. Attacker calls unstake with victim's pubkey as nft_holder
3. PDA seeds check passes (attacker can compute PDA for any holder)
4. Unstake executes for victim without victim's signature

**Simulation result**: CONFIRMED
- Attacker successfully called unstake for victim's NFT
- Fixed version correctly rejected non-signer
- Fixed version correctly accepted actual holder

**Fix**: Change `pub nft_holder: AccountInfo<'info>` to `pub nft_holder: Signer<'info>`.

## Combined Impact

These two vulnerabilities interact:
- **Current state**: TP2 (missing signer) enables unauthorized unstake, but TP1 (incomplete unstake) makes unstake a no-op anyway
- **If only TP1 were fixed**: Attacker could force-return NFTs to holders (forcing unstake)
- **If only TP2 were fixed**: Only the actual holder can call unstake, but NFT is still lost
- **Both must be fixed**: Signer check on unstake + actual NFT return logic

## Evidence Chain

| Step | Result |
|------|--------|
| Static analysis | 10 findings (5x ANCHOR-004, 5x ANCHOR-006) |
| Semantic analysis | 5 findings (2 TP, 3 INFO) |
| Code review | Confirmed incomplete unstake + missing signer |
| Python simulation | Both vulnerabilities reproduced |
| Bankrun execution | Not possible (no Solana toolchain) |
