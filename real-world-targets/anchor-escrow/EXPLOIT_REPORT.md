# Exploit Report: anchor-escrow (coral-xyz/anchor example)

## Program Overview

- **Source**: coral-xyz/anchor (tests/escrow)
- **Domain**: Token escrow / swap
- **Lines**: 260
- **Anchor version**: Modern (uses InterfaceAccount, TokenInterface, token_2022)
- **Status**: Framework example, not production code

## Compilation

- **Solana CLI**: Not available in environment
- **Bankrun execution**: Not possible without cargo-build-sbf
- **Alternative**: Python simulation exploit (faithful dataclass model)

## Exploit

### Exploit 1: Cancel Escrow Without Initializer Signature (SEM-001, High → Likely TP upgraded to Simulation Confirmed)

**File**: `exploits/exploit_anchor_escrow_001_cancel_without_signer.py`

**Vulnerability**: `initializer` in `CancelEscrow` (lib.rs:160-176) is `AccountInfo<'info>` without the `Signer` constraint. The constraint `escrow_account.initializer_key == *initializer.key` only verifies key equality, but `initializer_key` is stored on-chain and publicly readable.

**Vulnerable struct** (lib.rs:160-176):
```rust
#[derive(Accounts)]
pub struct CancelEscrow<'info> {
    /// CHECK:
    pub initializer: AccountInfo<'info>,       // <-- No Signer!
    #[account(mut)]
    pub pda_deposit_token_account: InterfaceAccount<'info, TokenAccount>,
    /// CHECK:
    pub pda_account: AccountInfo<'info>,
    #[account(
        mut,
        constraint = escrow_account.initializer_key == *initializer.key,
        constraint = escrow_account.initializer_deposit_token_account == ...,
        close = initializer
    )]
    pub escrow_account: Account<'info, EscrowAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}
```

**Exploit scenario**:
1. Initializer creates escrow (offers 100 token X for 50 token Y)
2. Attacker reads `escrow_account.initializer_key` from on-chain data
3. Attacker calls `cancel_escrow` with initializer's pubkey
4. Constraint check passes (key matches on-chain data)
5. PDA authority returns token account to initializer
6. Escrow account closed — taker can no longer exchange

**Impact**: Denial of Service
- Tokens return to initializer (no fund theft)
- But the pending exchange is permanently destroyed
- Attacker can grief ANY escrow repeatedly
- Trade cannot be completed; initializer must re-create escrow

**Simulation result**: CONFIRMED
- Attacker successfully cancelled escrow without being the initializer
- Fixed version (with Signer) correctly rejected attacker
- Fixed version correctly accepted actual initializer

**Fix**: Change `pub initializer: AccountInfo<'info>` to `pub initializer: Signer<'info>` in CancelEscrow.

**Note on severity**: This is DoS, not fund theft. The initializer gets their tokens back, but the trade is griefed. Severity is High (not Critical) because it requires no financial loss, only operational disruption.

## Evidence Chain

| Step | Result |
|------|--------|
| Static analysis | 0 findings (well-structured Anchor code) |
| Semantic analysis | 3 findings (1 LTP, 2 INFO) |
| Code review | Confirmed missing Signer on CancelEscrow.initializer |
| Python simulation | Vulnerability reproduced — unauthorized cancel succeeds |
| Bankrun execution | Not possible (no Solana toolchain) |

## Classification Update

Original classification: LIKELY TRUE POSITIVE
Updated classification: **SIMULATION CONFIRMED** (Python model reproduces the vulnerability)

Note: Full confirmation requires bankrun execution against a compiled SBF binary. The Python simulation faithfully models the Anchor constraint system and demonstrates the exploit logic is sound.
