from dataclasses import dataclass
import sys
from typing import Optional

@dataclass
class RewardInfo:
    reward_state: int = 0
    open_time: int = 0
    end_time: int = 0
    last_update_time: int = 0
    emissions_per_second_x64: int = 0
    reward_total_emissioned: int = 0
    reward_claimed: int = 0
    token_mint: str = ""
    token_vault: str = ""
    authority: str = ""
    reward_growth_global_x64: int = 0

@dataclass 
class PoolState:
    bump: int = 0
    amm_config: str = ""
    owner: str = ""
    token_mint_0: str = ""
    token_mint_1: str = ""
    token_vault_0: str = ""
    token_vault_1: str = ""
    observation_key: str = ""
    mint_decimals_0: int = 0
    mint_decimals_1: int = 0
    tick_spacing: int = 0
    liquidity: int = 0
    sqrt_price_x64: int = 0
    tick_current: int = 0
    padding3: int = 0
    padding4: int = 0
    fee_growth_global_0_x64: int = 0
    fee_growth_global_1_x64: int = 0
    protocol_fees_token_0: int = 0
    protocol_fees_token_1: int = 0
    swap_in_amount_token_0: int = 0
    swap_out_amount_token_1: int = 0
    swap_in_amount_token_1: int = 0
    swap_out_amount_token_0: int = 0
    status: int = 0
    padding: list = None
    reward_infos: list = None
    tick_array_bitmap: list = None
    total_fees_token_0: int = 0
    total_fees_claimed_token_0: int = 0
    total_fees_token_1: int = 0
    total_fees_claimed_token_1: int = 0
    fund_fees_token_0: int = 0
    fund_fees_token_1: int = 0
    open_time: int = 0
    recent_epoch: int = 0
    padding1: list = None
    padding2: list = None

    def __post_init__(self):
        if self.padding is None:
            self.padding = [0] * 7
        if self.reward_infos is None:
            self.reward_infos = [RewardInfo() for _ in range(3)]
        if self.tick_array_bitmap is None:
            self.tick_array_bitmap = [0] * 16
        if self.padding1 is None:
            self.padding1 = [0] * 24
        if self.padding2 is None:
            self.padding2 = [0] * 32

@dataclass
class PersonalPositionState:
    bump: int = 0
    nft_mint: str = ""
    pool_id: str = ""
    tick_lower_index: int = 0
    tick_upper_index: int = 0
    liquidity: int = 0
    fee_growth_inside_0_last_x64: int = 0
    fee_growth_inside_1_last_x64: int = 0
    token_fees_owed_0: int = 0
    token_fees_owed_1: int = 0
    reward_infos: list = None
    recent_epoch: int = 0
    
    def __post_init__(self):
        if self.reward_infos is None:
            self.reward_infos = [{"reward_amount_owed": 0} for _ in range(3)]

@dataclass
class TokenVault:
    mint: str = ""
    authority: str = ""
    amount: int = 0

def calculate_latest_token_fees(
    last_total_fees: int,
    fee_growth_inside_last_x64: int,
    fee_growth_inside_latest_x64: int,
    liquidity: int
) -> int:
    Q64 = 1 << 64
    fee_growth_delta = ((fee_growth_inside_latest_x64 - fee_growth_inside_last_x64) & ((1 << 128) - 1)) * liquidity // Q64
    return last_total_fees + (fee_growth_delta & ((1 << 64) - 1))

def decrease_liquidity_and_update_position(
    pool_state: PoolState,
    personal_position: PersonalPositionState,
    liquidity: int
) -> tuple:
    decrease_amount_0 = 0
    decrease_amount_1 = 0
    
    if liquidity > 0:
        decrease_amount_0 = 50000
        decrease_amount_1 = 75000
        
        personal_position.liquidity -= liquidity
    
    latest_fees_owed_0 = personal_position.token_fees_owed_0
    latest_fees_owed_1 = personal_position.token_fees_owed_1
    
    print(f"Checking unclaimed fees: pool_total_0={pool_state.total_fees_token_0}, pool_claimed_0={pool_state.total_fees_claimed_token_0}, position_owed_0={latest_fees_owed_0}")
    print(f"Checking unclaimed fees: pool_total_1={pool_state.total_fees_token_1}, pool_claimed_1={pool_state.total_fees_claimed_token_1}, position_owed_1={latest_fees_owed_1}")
    
    if (pool_state.total_fees_token_0 - pool_state.total_fees_claimed_token_0) < latest_fees_owed_0:
        print(f"ERROR: Insufficient unclaimed fees token_0: available={pool_state.total_fees_token_0 - pool_state.total_fees_claimed_token_0}, needed={latest_fees_owed_0}")
        raise Exception("Insufficient unclaimed fees token_0")
    
    if (pool_state.total_fees_token_1 - pool_state.total_fees_claimed_token_1) < latest_fees_owed_1:
        print(f"ERROR: Insufficient unclaimed fees token_1: available={pool_state.total_fees_token_1 - pool_state.total_fees_claimed_token_1}, needed={latest_fees_owed_1}")
        raise Exception("Insufficient unclaimed fees token_1")
    
    personal_position.token_fees_owed_0 = 0
    personal_position.token_fees_owed_1 = 0
    
    pool_state.total_fees_claimed_token_0 += latest_fees_owed_0
    pool_state.total_fees_claimed_token_1 += latest_fees_owed_1
    
    return (decrease_amount_0, latest_fees_owed_0, decrease_amount_1, latest_fees_owed_1)

def decrease_liquidity(
    pool_state: PoolState,
    personal_position: PersonalPositionState,
    token_vault_0: TokenVault,
    token_vault_1: TokenVault,
    liquidity: int,
    amount_0_min: int = 0,
    amount_1_min: int = 0
):
    print(f"\n--- decrease_liquidity called ---")
    print(f"Position liquidity: {personal_position.liquidity}")
    print(f"Decreasing by: {liquidity}")
    print(f"Position fees owed: token_0={personal_position.token_fees_owed_0}, token_1={personal_position.token_fees_owed_1}")
    print(f"Pool total fees: token_0={pool_state.total_fees_token_0}, token_1={pool_state.total_fees_token_1}")
    print(f"Pool claimed fees: token_0={pool_state.total_fees_claimed_token_0}, token_1={pool_state.total_fees_claimed_token_1}")
    print(f"Vault balances: token_0={token_vault_0.amount}, token_1={token_vault_1.amount}")
    
    if liquidity > personal_position.liquidity:
        raise Exception("Insufficient liquidity")
    
    decrease_amount_0, latest_fees_owed_0, decrease_amount_1, latest_fees_owed_1 = decrease_liquidity_and_update_position(
        pool_state, personal_position, liquidity
    )
    
    transfer_amount_0 = decrease_amount_0 + latest_fees_owed_0
    transfer_amount_1 = decrease_amount_1 + latest_fees_owed_1
    
    print(f"Transfer amounts: token_0={transfer_amount_0}, token_1={transfer_amount_1}")
    
    if transfer_amount_0 > token_vault_0.amount:
        print(f"ERROR: Insufficient vault balance token_0: available={token_vault_0.amount}, needed={transfer_amount_0}")
        raise Exception("Insufficient vault balance token_0")
    
    if transfer_amount_1 > token_vault_1.amount:
        print(f"ERROR: Insufficient vault balance token_1: available={token_vault_1.amount}, needed={transfer_amount_1}")
        raise Exception("Insufficient vault balance token_1")
    
    token_vault_0.amount -= transfer_amount_0
    token_vault_1.amount -= transfer_amount_1
    
    print(f"Final vault balances: token_0={token_vault_0.amount}, token_1={token_vault_1.amount}")
    print(f"Final pool state: total_claimed_0={pool_state.total_fees_claimed_token_0}, total_claimed_1={pool_state.total_fees_claimed_token_1}")

def simulate_concurrent_fee_collection():
    pool_state = PoolState()
    token_vault_0 = TokenVault(amount=1000000)
    token_vault_1 = TokenVault(amount=1000000)
    
    pool_state.total_fees_token_0 = 50000
    pool_state.total_fees_claimed_token_0 = 10000
    pool_state.total_fees_token_1 = 40000
    pool_state.total_fees_claimed_token_1 = 8000
    
    user_a_position = PersonalPositionState()
    user_a_position.liquidity = 100000
    user_a_position.token_fees_owed_0 = 20000
    user_a_position.token_fees_owed_1 = 15000
    
    user_b_position = PersonalPositionState()
    user_b_position.liquidity = 50000
    user_b_position.token_fees_owed_0 = 25000
    user_b_position.token_fees_owed_1 = 18000
    
    print("=== INITIAL STATE ===")
    print(f"Pool total fees: token_0={pool_state.total_fees_token_0}, token_1={pool_state.total_fees_token_1}")
    print(f"Pool claimed fees: token_0={pool_state.total_fees_claimed_token_0}, token_1={pool_state.total_fees_claimed_token_1}")
    print(f"Available unclaimed: token_0={pool_state.total_fees_token_0 - pool_state.total_fees_claimed_token_0}, token_1={pool_state.total_fees_token_1 - pool_state.total_fees_claimed_token_1}")
    print(f"User A fees owed: token_0={user_a_position.token_fees_owed_0}, token_1={user_a_position.token_fees_owed_1}")
    print(f"User B fees owed: token_0={user_b_position.token_fees_owed_0}, token_1={user_b_position.token_fees_owed_1}")
    print(f"Combined fees owed: token_0={user_a_position.token_fees_owed_0 + user_b_position.token_fees_owed_0}, token_1={user_a_position.token_fees_owed_1 + user_b_position.token_fees_owed_1}")
    
    available_fees_0 = pool_state.total_fees_token_0 - pool_state.total_fees_claimed_token_0
    available_fees_1 = pool_state.total_fees_token_1 - pool_state.total_fees_claimed_token_1
    total_owed_0 = user_a_position.token_fees_owed_0 + user_b_position.token_fees_owed_0
    total_owed_1 = user_a_position.token_fees_owed_1 + user_b_position.token_fees_owed_1
    
    print(f"\nVULNERABILITY CHECK:")
    print(f"Available token_0: {available_fees_0}, Total owed: {total_owed_0} -> {'VULNERABLE' if total_owed_0 > available_fees_0 else 'OK'}")
    print(f"Available token_1: {available_fees_1}, Total owed: {total_owed_1} -> {'VULNERABLE' if total_owed_1 > available_fees_1 else 'OK'}")
    
    print("\n=== SIMULATING RACE CONDITION ===")
    
    try:
        print("\n--- User A calls decrease_liquidity ---")
        pool_state_a = PoolState(**pool_state.__dict__)
        pool_state_a.reward_infos = [RewardInfo(**ri.__dict__) for ri in pool_state.reward_infos]
        user_a_pos_copy = PersonalPositionState(**user_a_position.__dict__)
        user_a_pos_copy.reward_infos = [ri.copy() for ri in user_a_position.reward_infos]
        vault_0_a = TokenVault(**token_vault_0.__dict__)
        vault_1_a = TokenVault(**token_vault_1.__dict__)
        
        decrease_liquidity(pool_state_a, user_a_pos_copy, vault_0_a, vault_1_a, 50000)
        print("✓ User A transaction would succeed")
        
    except Exception as e:
        print(f"✗ User A transaction failed: {e}")
    
    try:
        print("\n--- User B calls decrease_liquidity (using original pool state) ---")
        pool_state_b = PoolState(**pool_state.__dict__)
        pool_state_b.reward_infos = [RewardInfo(**ri.__dict__) for ri in pool_state.reward_infos]
        user_b_pos_copy = PersonalPositionState(**user_b_position.__dict__)
        user_b_pos_copy.reward_infos = [ri.copy() for ri in user_b_position.reward_infos]
        vault_0_b = TokenVault(**token_vault_0.__dict__)
        vault_1_b = TokenVault(**token_vault_1.__dict__)
        
        decrease_liquidity(pool_state_b, user_b_pos_copy, vault_0_b, vault_1_b, 25000)
        print("✓ User B transaction would succeed")
        
    except Exception as e:
        print(f"✗ User B transaction failed: {e}")
    
    print("\n=== SIMULATING BOTH TRANSACTIONS COMMITTING ===")
    
    final_pool_state = PoolState(**pool_state.__dict__)
    final_pool_state.reward_infos = [RewardInfo(**ri.__dict__) for ri in pool_state.reward_infos]
    
    print("\nCommitting User A's fee claims...")
    final_pool_state.total_fees_claimed_token_0 += user_a_position.token_fees_owed_0
    final