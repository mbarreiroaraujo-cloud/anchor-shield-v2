"""Exploit PoC: Unstake never returns NFT (solana-staking SEM-001).

Demonstrates that the unstake function only logs time_diff and returns Ok(()).
It NEVER transfers the NFT back from the vault to the holder, and NEVER
decrements staked_nfts. Staked NFTs are permanently lost.

Source: rpajo/solana-staking (lib.rs lines 85-102)
Vulnerable code:
    pub fn unstake(...) -> ProgramResult {
        let time_diff = clock.unix_timestamp - nft_stake_data.staking_date;
        msg!("Staked at {}, time diff: {}", ...);
        Ok(())  // <-- No transfer, no state update
    }
"""
from dataclasses import dataclass, field
from typing import Optional


@dataclass
class StakingMachine:
    """Simulates the on-chain StakingMachine account."""
    staked_nfts: int = 0
    nft_vault: str = "vault_pubkey"


@dataclass
class StakingAccount:
    """Simulates the on-chain StakingAccount PDA."""
    staking_date: int = 0


@dataclass
class TokenAccount:
    """Simulates an SPL token account holding an NFT."""
    owner: str = ""
    amount: int = 0


def stake(
    staking_machine: StakingMachine,
    nft_holder_token: TokenAccount,
    vault_token: TokenAccount,
    nft_stake_data: StakingAccount,
    clock_timestamp: int,
) -> bool:
    """Simulates the stake instruction (lines 43-83).

    This correctly transfers the NFT via CPI and updates state.
    """
    if nft_holder_token.amount < 1:
        print("  stake() -> REJECTED: no NFT to stake")
        return False

    # CPI: token::transfer(from=nft_token, to=nft_vault, amount=1)
    nft_holder_token.amount -= 1
    vault_token.amount += 1

    # State updates
    staking_machine.staked_nfts += 1
    nft_stake_data.staking_date = clock_timestamp

    print(f"  stake() -> OK: NFT transferred to vault, staked_nfts={staking_machine.staked_nfts}")
    return True


def unstake_vulnerable(
    staking_machine: StakingMachine,
    nft_holder_token: TokenAccount,
    vault_token: TokenAccount,
    nft_stake_data: StakingAccount,
    clock_timestamp: int,
) -> bool:
    """Simulates the VULNERABLE unstake instruction (lines 85-102).

    BUG: Only calculates time_diff and logs. Never:
    1. Transfers NFT back from vault to holder
    2. Decrements staking_machine.staked_nfts
    3. Closes the staking account
    """
    time_diff = clock_timestamp - nft_stake_data.staking_date
    print(f"  unstake() -> OK: time_diff={time_diff}")
    print(f"    vault still holds NFT: amount={vault_token.amount}")
    print(f"    holder token account: amount={nft_holder_token.amount}")
    print(f"    staked_nfts still: {staking_machine.staked_nfts}")
    # No transfer, no state update — just returns Ok(())
    return True


def unstake_fixed(
    staking_machine: StakingMachine,
    nft_holder_token: TokenAccount,
    vault_token: TokenAccount,
    nft_stake_data: StakingAccount,
    clock_timestamp: int,
) -> bool:
    """What the CORRECT unstake should look like."""
    time_diff = clock_timestamp - nft_stake_data.staking_date

    # Transfer NFT back from vault to holder
    vault_token.amount -= 1
    nft_holder_token.amount += 1

    # Update state
    staking_machine.staked_nfts -= 1

    print(f"  unstake_fixed() -> OK: NFT returned, staked_nfts={staking_machine.staked_nfts}")
    return True


def main():
    print("=" * 60)
    print("EXPLOIT: Unstake Never Returns NFT (solana-staking)")
    print("=" * 60)

    machine = StakingMachine()
    holder_token = TokenAccount(owner="holder_pubkey", amount=1)
    vault_token = TokenAccount(owner="vault_pubkey", amount=0)
    stake_data = StakingAccount()

    # Step 1: Stake an NFT at timestamp 1000
    print("\nStep 1: Stake NFT")
    assert stake(machine, holder_token, vault_token, stake_data, clock_timestamp=1000)

    assert holder_token.amount == 0, "Holder should have 0 NFTs after staking"
    assert vault_token.amount == 1, "Vault should hold 1 NFT"
    assert machine.staked_nfts == 1, "staked_nfts should be 1"

    # Step 2: Unstake at timestamp 2000 (vulnerable version)
    print("\nStep 2: Unstake NFT (vulnerable — should return NFT but doesn't)")
    assert unstake_vulnerable(machine, holder_token, vault_token, stake_data, clock_timestamp=2000)

    # Step 3: Verify the NFT was NOT returned
    print("\nStep 3: Verify NFT is permanently lost")

    print(f"\n  Holder NFT balance: {holder_token.amount} (expected: 1 if fixed, 0 if vulnerable)")
    print(f"  Vault NFT balance:  {vault_token.amount} (expected: 0 if fixed, 1 if vulnerable)")
    print(f"  staked_nfts:        {machine.staked_nfts} (expected: 0 if fixed, 1 if vulnerable)")

    assert holder_token.amount == 0, "EXPLOIT: Holder did NOT get NFT back"
    assert vault_token.amount == 1, "EXPLOIT: Vault still holds the NFT"
    assert machine.staked_nfts == 1, "EXPLOIT: staked_nfts was never decremented"

    print("\n" + "=" * 60)
    print("EXPLOIT RESULT:")
    print("  The unstake function completed successfully (Ok(()))")
    print("  but the NFT was NEVER transferred back from the vault.")
    print("  The holder permanently lost their NFT.")
    print("  staked_nfts counter was never decremented.")
    print("\n  Root cause: unstake() only computes time_diff and logs.")
    print("  Missing: token::transfer CPI to return NFT")
    print("  Missing: staking_machine.staked_nfts -= 1")
    print("\n  >>> EXPLOIT CONFIRMED: NFT permanently locked in vault <<<")
    print("=" * 60)


if __name__ == "__main__":
    main()
